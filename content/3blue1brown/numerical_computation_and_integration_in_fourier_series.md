---
title: Numerical computation and integration in Fourier series
videoId: r6sGWTCMz2k
---

From: [[3blue1brown]] <br/> 

The mathematical framework of [[complex_fourier_series_and_rotating_vectors | complex Fourier series]] allows for the decomposition of complex functions—which can be visualized as 2D drawings—into a sum of rotating vectors <a class="yt-timestamp" data-t="00:10:04">[00:10:04]</a>. To render animations, a path (treated as a complex function) is decomposed into these vectors by computing specific coefficients <a class="yt-timestamp" data-t="00:20:36">[00:20:36]</a>.

## Finding Fourier Coefficients (c sub n)

The goal is to express an arbitrary function `f(t)` as a sum of terms, each representing a little vector rotating at a constant integer frequency <a class="yt-timestamp" data-t="00:50:56">[00:50:56]</a> <a class="yt-timestamp" data-t="00:10:04">[00:10:04]</a>. Each term is given by `c_n * e^(n * 2pi * i * t)`, where `c_n` is a complex constant determining the initial size and angle of the vector <a class="yt-timestamp" data-t="00:15:43">[00:15:43]</a> <a class="yt-timestamp" data-t="00:15:47">[00:15:47]</a>. The key challenge lies in finding these `c_n` coefficients <a class="yt-timestamp" data-t="00:09:47">[00:09:47]</a>.

### The Constant Term (c0)

The constant term, `c0`, represents a "center of mass" for the full drawing <a class="yt-timestamp" data-t="00:16:55">[00:16:55]</a>. It can be found by taking the continuous average of the function `f(t)` over its input range, typically from 0 to 1 <a class="yt-timestamp" data-t="00:17:11">[00:17:11]</a>. This average is an integral of `f(t)` from 0 to 1 <a class="yt-timestamp" data-t="00:17:20">[00:17:20]</a> <a class="yt-timestamp" data-t="00:17:24">[00:17:24]</a>.

When this integral is applied to the entire sum of rotating vectors, all terms that rotate (i.e., those with non-zero frequencies) average out to zero as they complete whole numbers of rotations around 0 <a class="yt-timestamp" data-t="00:18:22">[00:18:22]</a> <a class="yt-timestamp" data-t="00:18:27">[00:18:27]</a> <a class="yt-timestamp" data-t="00:18:31">[00:18:31]</a>. The only exception is the constant term (`c0`), which remains static and its average value is simply `c0` <a class="yt-timestamp" data-t="00:18:33">[00:18:33]</a> <a class="yt-timestamp" data-t="00:18:37">[00:18:37]</a>. Thus, integrating the function `f(t)` effectively isolates `c0` <a class="yt-timestamp" data-t="00:18:41">[00:18:41]</a> <a class="yt-timestamp" data-t="00:18:44">[00:18:44]</a>.

### General Formula for `c_n`

To find any other coefficient, `c_n`, the trick is to first multiply the entire function `f(t)` by `e^(-n * 2pi * i * t)` <a class="yt-timestamp" data-t="00:18:49">[00:18:49]</a> <a class="yt-timestamp" data-t="00:18:56">[00:18:56]</a> <a class="yt-timestamp" data-t="00:19:01">[00:19:01]</a>. This operation has the effect of shifting the frequency term in each exponent down by `n` <a class="yt-timestamp" data-t="00:19:16">[00:19:16]</a> <a class="yt-timestamp" data-t="00:19:21">[00:19:21]</a>. Specifically, it makes the `n`-th vector component (associated with `c_n`) effectively "hold still" <a class="yt-timestamp" data-t="00:18:56">[00:18:56]</a> <a class="yt-timestamp" data-t="00:19:01">[00:19:01]</a>.

After this multiplication, when the average (integral) is taken, all other vector terms (`c_k` where `k` is not `n`) will still make a whole number of rotations, causing their averages to be zero <a class="yt-timestamp" data-t="00:19:46">[00:19:46]</a> <a class="yt-timestamp" data-t="00:19:51">[00:19:51]</a>. The only term that does not average to zero is the `c_n` term, which is now static <a class="yt-timestamp" data-t="00:19:55">[00:19:55]</a>. This provides a general formula for `c_n` <a class="yt-timestamp" data-t="00:20:02">[00:20:02]</a> <a class="yt-timestamp" data-t="00:20:05">[00:20:05]</a>.

The formula for `c_n` is the integral of `f(t) * e^(-n * 2pi * i * t)` from 0 to 1 <a class="yt-timestamp" data-t="00:20:05">[00:20:05]</a>. This expression can be interpreted as modifying the 2D drawing (`f(t)`) to make the `n`-th vector hold still, then performing an average that eliminates all moving vectors, leaving only the still part <a class="yt-timestamp" data-t="00:20:10">[00:20:10]</a> <a class="yt-timestamp" data-t="00:20:14">[00:20:14]</a> <a class="yt-timestamp" data-t="00:20:17">[00:20:17]</a> <a class="yt-timestamp" data-t="00:20:20">[00:20:20]</a>.

## Numerical Computation

When rendering animations, computers treat the path as a complex function and compute these integrals for a specific range of `n` values to find the coefficients `c_n` <a class="yt-timestamp" data-t="00:20:36">[00:20:36]</a> <a class="yt-timestamp" data-t="00:20:41">[00:20:41]</a> <a class="yt-timestamp" data-t="00:20:45">[00:20:45]</a>. For example, using 101 rotating vectors means computing `n` from -50 to 50 <a class="yt-timestamp" data-t="00:21:10">[00:21:10]</a> <a class="yt-timestamp" data-t="00:21:14">[00:21:14]</a>.

In practice, each of these integrals is computed numerically <a class="yt-timestamp" data-t="00:21:18">[00:21:18]</a>. This involves chopping the unit interval (the input range from 0 to 1) into many small pieces of size `delta t` <a class="yt-timestamp" data-t="00:21:21">[00:21:21]</a> <a class="yt-timestamp" data-t="00:21:26">[00:21:26]</a>. Then, the value `f(t) * e^(-n * 2pi * i * t) * delta t` is summed for each piece <a class="yt-timestamp" data-t="00:21:26">[00:21:26]</a> <a class="yt-timestamp" data-t="00:21:31">[00:21:31]</a>. While fancier methods exist for more efficient numerical integration, this provides the basic idea <a class="yt-timestamp" data-t="00:21:33">[00:21:33]</a> <a class="yt-timestamp" data-t="00:21:36">[00:21:36]</a>.

After computing these constants, each `c_n` determines the initial angle and magnitude for its corresponding vector. These vectors are then set into rotation and added tip-to-tail to draw an approximation of the original path <a class="yt-timestamp" data-t="00:21:38">[00:21:38]</a> <a class="yt-timestamp" data-t="00:21:42">[00:21:42]</a> <a class="yt-timestamp" data-t="00:21:47">[00:21:47]</a>. The accuracy of this approximation improves as the number of vectors used approaches infinity <a class="yt-timestamp" data-t="00:21:55">[00:21:55]</a> <a class="yt-timestamp" data-t="00:21:57">[00:21:57]</a>.

For certain functions, like the step function used to model heat dissipation, the calculus for these integrals can be done by hand to get an exact answer, but generally, computers perform the numerical computation <a class="yt-timestamp" data-t="00:23:06">[00:23:06]</a> <a class="yt-timestamp" data-t="00:23:09">[00:23:09]</a> <a class="yt-timestamp" data-t="00:23:13">[00:23:13]</a> <a class="yt-timestamp" data-t="00:23:16">[00:23:16]</a>. The concept of [[infinite_series_and_sum_computations | infinite sum]] allows an [[fourier_series_and_sine_waves | infinite sum]] of wavy continuous functions to equal a discontinuous flat function, a qualitative change impossible with finite sums alone <a class="yt-timestamp" data-t="00:08:40">[00:08:40]</a> <a class="yt-timestamp" data-t="00:08:47">[00:08:47]</a> <a class="yt-timestamp" data-t="00:08:50">[00:08:50]</a>. However, questions related to the strict truth of such sums or whether all functions possess a [[complex_fourier_series_and_rotating_vectors | Fourier series]] are handled by [[mathematical_analysis_of_fourier_series | real analysis]] <a class="yt-timestamp" data-t="00:09:13">[00:09:13]</a> <a class="yt-timestamp" data-t="00:09:17">[00:09:17]</a> <a class="yt-timestamp" data-t="00:09:19">[00:09:19]</a>.