---
title: Potential Evidence and Counterexamples for Collatz Conjecture
videoId: 094y1Z2wpJg
---

From: [[veritasium]] <br/> 
The [[collatz_conjecture_explanation | Collatz Conjecture]], also known as the Ulam conjecture, Kakutani's problem, Thwaites conjecture, Hasse's algorithm, the Syracuse problem, or simply 3N+1, is considered "the most dangerous problem in mathematics" <a class="yt-timestamp" data-t="00:00:00">[00:00:00]</a>. Young mathematicians are often warned not to spend time on it, as even the world's best mathematicians have been unable to solve it <a class="yt-timestamp" data-t="00:00:03">[00:00:03]</a>. Paul Erdos, a famous mathematician, stated, "Mathematics is not yet ripe enough for such questions" <a class="yt-timestamp" data-t="00:00:16">[00:00:16]</a>. Jeffrey Lagarias, considered the world authority on 3x+1, advises against working on it for career progression <a class="yt-timestamp" data-t="00:03:47">[00:03:47]</a>.

The conjecture states that if you take any positive integer and repeatedly apply two rules – if the number is odd, multiply by three and add one; if the number is even, divide by two – it will eventually reach the "four, two, one loop" (4 → 2 → 1 → 4) <a class="yt-timestamp" data-t="00:01:33">[00:01:33]</a>. The numbers generated by this process are called hailstone numbers because they rise and fall like hailstones before eventually "falling down to one" <a class="yt-timestamp" data-t="00:02:17">[00:02:17]</a>.

## Evidence Supporting the Conjecture

### Brute Force Testing
Vast computational efforts have been made to test the conjecture. Every single number up to two to the 68 (approximately 295 quintillion numbers) has been tested, and all of them have been confirmed to eventually reach the four, two, one loop <a class="yt-timestamp" data-t="00:10:31">[00:10:31]</a>. Based on this, mathematicians estimate that any other potential loop would need to be at least 186 billion numbers long <a class="yt-timestamp" data-t="00:11:03">[00:11:03]</a>.

### Statistical Tendency to Shrink
Despite odd numbers being more than tripled and even numbers only halved, the sequence statistically tends to shrink <a class="yt-timestamp" data-t="00:07:07">[00:07:07]</a>. This is because every time an odd number is multiplied by three and one is added, the result is always an even number, which then *must* be divided by two <a class="yt-timestamp" data-t="00:07:30">[00:07:30]</a>. This effectively means odd numbers are increased by a factor of about 3/2 <a class="yt-timestamp" data-t="00:07:40">[00:07:40]</a>.

When considering the path from one odd number to the next odd number in the sequence:
*   50% of the time, the next odd number is reached after dividing by 2 (factor of 3/2) <a class="yt-timestamp" data-t="00:08:05">[00:08:05]</a>.
*   25% of the time, it divides by 4 (factor of 3/4) <a class="yt-timestamp" data-t="00:08:10">[00:08:10]</a>.
*   12.5% of the time, it divides by 8 (factor of 3/8) <a class="yt-timestamp" data-t="00:08:21">[00:08:21]</a>.
*   And so on <a class="yt-timestamp" data-t="00:08:25">[00:08:25]</a>.

Taking the geometric mean of these factors (3/2, 3/4, 3/8, etc.), it averages out to 3/4, which is less than one <a class="yt-timestamp" data-t="00:08:29">[00:08:29]</a>. This statistical analysis suggests that sequences are more likely to shrink than grow <a class="yt-timestamp" data-t="00:08:39">[00:08:39]</a>.

### Benford's Law
Analyzing the leading digits of numbers in Collatz sequences reveals a pattern consistent with Benford's Law <a class="yt-timestamp" data-t="00:05:16">[00:05:16]</a>. For instance, across the first billion sequences, approximately 30% of numbers start with one, and the frequency decreases for higher digits <a class="yt-timestamp" data-t="00:05:53">[00:05:53]</a>. This law appears in many natural datasets where numbers span several orders of magnitude <a class="yt-timestamp" data-t="00:06:15">[00:06:15]</a>. While interesting, Benford's law cannot prove whether all numbers eventually reach the loop <a class="yt-timestamp" data-t="00:06:57">[00:06:57]</a>.

### Terry Tao's Proof
In 2019, renowned mathematician Terry Tao demonstrated that "almost all numbers" in Collatz sequences will eventually become smaller than *any* arbitrarily slowly rising function (e.g., log x or log log x) <a class="yt-timestamp" data-t="00:12:35">[00:12:35]</a>. This means that for almost all numbers, there's a guarantee of finding an arbitrarily small number somewhere in its sequence <a class="yt-timestamp" data-t="00:13:04">[00:13:04]</a>. Tao stated that this is "about as close as one can get to the Collatz conjecture without actually solving it" <a class="yt-timestamp" data-t="00:13:13">[00:13:13]</a>.

## Potential Counterexamples or Reasons It Might Be False

The conjecture could be false in two ways <a class="yt-timestamp" data-t="00:09:58">[00:09:58]</a>:
1.  **Divergent sequence**: A number's sequence grows indefinitely to infinity, never returning to one <a class="yt-timestamp" data-t="00:10:01">[00:10:01]</a>.
2.  **Undiscovered loop**: A sequence of numbers forms a closed loop other than the four, two, one loop, remaining unconnected to the main graph <a class="yt-timestamp" data-t="00:10:14">[00:10:14]</a>.

To date, no such divergent sequence or alternative loop has been found <a class="yt-timestamp" data-t="00:10:25">[00:10:25]</a>.

### Arguments for its Falsity
Some mathematicians suggest that the sheer difficulty in proving the conjecture might indicate it's not true <a class="yt-timestamp" data-t="00:13:27">[00:13:27]</a>. If everyone is trying to prove it true, few are actively searching for counterexamples, which sometimes leads to breakthroughs <a class="yt-timestamp" data-t="00:13:34">[00:13:34]</a>.

### Analogy to Polya Conjecture
The Polya conjecture, proposed in 1919, stated that the majority of natural numbers up to any given number have an odd number of prime factors <a class="yt-timestamp" data-t="00:16:24">[00:16:24]</a>. This conjecture was proven false in 1958 by C. Brian Haselgrove, who found a counterexample at 1.845 x 10^361 <a class="yt-timestamp" data-t="00:16:34">[00:16:34]</a>. This counterexample is astronomically larger (10^340 times) than the numbers tested for the Collatz conjecture (up to 2^68) <a class="yt-timestamp" data-t="00:16:48">[00:16:48]</a>. This suggests that even extensive brute-force testing doesn't guarantee a conjecture's truth across all numbers.

### Turing Machine Analogy
Thinking of the [[collatz_conjecture_explanation | Collatz Conjecture]] as a simple program running on a Turing machine where the seed number is the input, testing inputs up to 68 bits long does not provide strong confidence that it will work for all inputs <a class="yt-timestamp" data-t="00:16:54">[00:16:54]</a>. It's possible to calculate numbers that will exhibit specific, finite behaviors (e.g., increase by 3/2 for a hundred consecutive times), but control is lost after that specified section <a class="yt-timestamp" data-t="00:17:24">[00:17:24]</a>.

### Behavior with Negative Numbers
When the same 3x+1 rules are applied to negative numbers, three independent loops have been identified, starting at low values like -17 and -5 <a class="yt-timestamp" data-t="00:14:44">[00:14:44]</a>. The existence of disconnected loops on the negative side of the number line raises questions about why they wouldn't exist on the positive side <a class="yt-timestamp" data-t="00:15:03">[00:15:03]</a>.

### "Almost All" vs. "All"
Terry Tao's proof applies to "almost all numbers," which has a precise mathematical definition: as the numbers being considered go to infinity, the fraction that obeys the criteria goes to one <a class="yt-timestamp" data-t="00:15:19">[00:15:19]</a>. However, proving "almost all" numbers obey a criterion is not the same as proving "all" numbers do <a class="yt-timestamp" data-t="00:15:22">[00:15:22]</a>. For example, "almost all numbers are not perfect squares" (because the percentage of perfect squares approaches zero as numbers go to infinity), yet there are infinitely many perfect squares <a class="yt-timestamp" data-t="00:15:58">[00:15:58]</a>. This highlights that a statistical tendency does not rule out the existence of rare, specific counterexamples.

## Undecidability
Another possibility is that the [[collatz_conjecture_explanation | Collatz Conjecture]] is undecidable, meaning it can never be proven true or false within our current mathematical framework <a class="yt-timestamp" data-t="00:18:50">[00:18:50]</a>. In 1987, John Conway created a generalization of 3x+1 called FRACTRAN, a Turing-complete mathematical machine <a class="yt-timestamp" data-t="00:18:55">[00:18:55]</a>. Because FRACTRAN is Turing-complete, it is subject to the halting problem, meaning it's impossible to determine if the machine will ever stop running for an arbitrary input <a class="yt-timestamp" data-t="00:19:11">[00:19:11]</a>. While this doesn't directly prove that 3x+1 is also subject to the halting problem, it suggests the possibility that the conjecture might be inherently unprovable <a class="yt-timestamp" data-t="00:19:21">[00:19:21]</a>.

The difficulty in solving the Collatz conjecture underscores the complexity of mathematics, showing that simple-looking problems can be profoundly intractable <a class="yt-timestamp" data-t="00:19:36">[00:19:36]</a>. It highlights the peculiar and intricate nature of numbers, where a basic operation can lead to organic-looking, complex structures, and the question of whether all numbers connect to this structure or if a unique thread runs off to infinity remains unanswered <a class="yt-timestamp" data-t="00:20:04">[00:20:04]</a>.