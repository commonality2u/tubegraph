---
title: Comparison of Monad and Ethereum Blockchains
videoId: hXxU3epZw9E
---

From: [[thepipeline_xyz]] <br/> 

[[Introduction to Monad and its community | Monad]] is a blockchain platform described as a "full scratch redesign" <a class="yt-timestamp" data-t="00:22:22">[00:22:22]</a> of the Ethereum Virtual Machine (EVM) architecture <a class="yt-timestamp" data-t="00:30:17">[00:30:17]</a>. While maintaining full EVM RPC compatibility <a class="yt-timestamp" data-t="01:02:12">[01:02:12]</a>, allowing existing wallets and indexers to function seamlessly <a class="yt-timestamp" data-t="01:07:35">[01:07:35]</a>, [[Monad blockchain technology | Monad]] aims to significantly improve performance <a class="yt-timestamp" data-t="00:38:23">[00:38:23]</a>.

## Performance and User Experience
[[Monad blockchain and its performance optimizations | Monad]] targets 10,000 transactions per second (TPS) <a class="yt-timestamp" data-t="00:39:18">[00:39:18]</a>, specifically meaning "real historical Ethereum transactions" <a class="yt-timestamp" data-t="00:45:07">[00:45:07]</a>, not merely simple transfers <a class="yt-timestamp" data-t="00:43:53">[00:43:53]</a>. It offers single block times and single slot finality <a class="yt-timestamp" data-t="00:58:32">[00:58:32]</a>, and transaction costs are anticipated to be "hundreds of a cent for Uniswap V2 transaction" <a class="yt-timestamp" data-t="01:30:46">[01:30:46]</a>. For developers, [[Monad blockchain technology | Monad]] is a "fully EVM equivalent L1" <a class="yt-timestamp" data-t="01:50:35">[01:50:35]</a>, making it possible to port existing contracts and leverage the EVM ecosystem <a class="yt-timestamp" data-t="01:53:30">[01:53:30]</a>.

Despite its high performance goals, [[Monad blockchain technology | Monad]] aims to maintain decentralization with "hundreds of nodes participating in consensus around the globe" <a class="yt-timestamp" data-t="01:38:09">[01:38:09]</a>, while keeping hardware requirements reasonable <a class="yt-timestamp" data-t="01:42:37">[01:42:37]</a> <a class="yt-timestamp" data-t="04:11:06">[04:11:06]</a>. This contrasts with other blockchains that achieve performance by requiring faster internet connections (e.g., 1 GB or 10 GB vs. Monad's 100 Mbps target for a full node) <a class="yt-timestamp" data-t="03:00:23">[03:00:23]</a> <a class="yt-timestamp" data-t="03:08:48">[03:08:48]</a>, placing nodes close together to reduce latency <a class="yt-timestamp" data-t="03:23:42">[03:23:42]</a>, or requiring significant RAM <a class="yt-timestamp" data-t="03:39:07">[03:39:07]</a>.

## Core Technical Innovations
[[Monad blockchain and its performance optimizations | Monad]]'s performance is achieved through a new software architecture <a class="yt-timestamp" data-t="04:20:00">[04:20:00]</a>, rebuilding consensus, its execution engine, implementing parallel execution, and a custom state database called [[Monad DB | Monad DB]] <a class="yt-timestamp" data-t="04:32:00">[04:32:00]</a>. The only component retained from standard EVM is the bytecode <a class="yt-timestamp" data-t="04:37:34">[04:37:34]</a>.

### Asynchronous Execution
Most blockchains today, including Ethereum, use "interleaved execution" <a class="yt-timestamp" data-t="05:20:00">[05:20:00]</a>, where execution and consensus occur in tandem within a block time <a class="yt-timestamp" data-t="05:29:05">[05:29:05]</a>. In Ethereum's 12-second block time <a class="yt-timestamp" data-t="05:35:05">[05:35:05]</a>, execution takes only about 1% of the time, with consensus taking the majority due to global communication latency <a class="yt-timestamp" data-t="05:46:04">[05:46:04]</a>.

[[Monad blockchain and its performance optimizations | Monad]] employs "asynchronous execution" <a class="yt-timestamp" data-t="06:20:00">[06:20:00]</a>, which stems from the realization that execution can be pulled out of the current block's consensus process <a class="yt-timestamp" data-t="06:28:00">[06:28:00]</a>. Since the EVM is a deterministic state machine and the ordering and data of transactions are known <a class="yt-timestamp" data-t="06:37:00">[06:37:00]</a>, the execution results are predictable <a class="yt-timestamp" data-t="06:45:00">[06:45:00]</a>.

This means [[Monad blockchain and its performance optimizations | Monad]] orders the current block while simultaneously executing the *previous* block <a class="yt-timestamp" data-t="07:15:00">[07:15:00]</a>. This separation allows consensus and execution to run on different timelines, effectively expanding the execution budget and gas budget <a class="yt-timestamp" data-t="08:29:00">[08:29:00]</a>, leading to higher throughput and lower fees <a class="yt-timestamp" data-t="08:36:00">[08:36:00]</a>. Finality is achieved at consensus time because the transaction order and data are final <a class="yt-timestamp" data-t="09:48:00">[09:48:00]</a>.

### Parallel Execution
Traditional blockchains linearly order and serially execute transactions <a class="yt-timestamp" data-t="10:46:00">[10:46:00]</a>. [[Monad blockchain and its performance optimizations | Monad]] leverages modern multi-core hardware by implementing "optimistic parallel execution" <a class="yt-timestamp" data-t="11:13:00">[11:13:00]</a>, also known as software transactional memory (STM) or optimistic concurrency control (OCC) <a class="yt-timestamp" data-t="11:17:00">[11:17:00]</a>.

This method assumes all transactions can run in parallel, generates pending results, and then commits them in order <a class="yt-timestamp" data-t="11:28:00">[11:28:00]</a>. If a transaction relied on a state change from a previous, conflicting transaction, it is re-executed with the updated state <a class="yt-timestamp" data-t="11:43:00">[11:43:00]</a>. Because the most time-consuming part of transaction processing is fetching state from the database, not execution itself <a class="yt-timestamp" data-t="13:25:00">[13:25:00]</a>, the overhead of re-execution is minimal as the state is already cached <a class="yt-timestamp" data-t="13:50:00">[13:50:00]</a>. This approach eliminates the need for developers to deal with "access lists," simplifying the development experience while maintaining high performance <a class="yt-timestamp" data-t="13:59:00">[13:59:00]</a>.

### [[Role and Architecture of Monad DB in Optimizing Blockchain Efficiency | Monad DB]]
[[Monad DB | Monad DB]] is a custom state database crucial for enabling parallel execution <a class="yt-timestamp" data-t="14:29:00">[14:29:00]</a>. It allows for "parallel state access" <a class="yt-timestamp" data-t="15:04:00">[15:04:00]</a>, addressing the bottleneck where the system would otherwise wait for state dependencies to be pulled from the database for each transaction <a class="yt-timestamp" data-t="15:10:00">[15:10:00]</a>. [[Role and Architecture of Monad DB in Optimizing Blockchain Efficiency | Monad DB]] uses "asynchronous IO" <a class="yt-timestamp" data-t="15:25:00">[15:25:00]</a>, allowing multiple requests to the database in parallel <a class="yt-timestamp" data-t="15:27:00">[15:27:00]</a>, ensuring the system's compute resources are saturated <a class="yt-timestamp" data-t="16:09:00">[16:09:00]</a>.

#### [[Difference between Monad Database and traditional databases | Merkle Patricia Tries and Database Structure]]
Ethereum stores its state in a "Merkle Patricia Try" (MPT) <a class="yt-timestamp" data-t="16:32:00">[16:32:00]</a>. This structure is fundamental to Ethereum's philosophy of "succinct verification of transactions and state" <a class="yt-timestamp" data-t="17:21:00">[17:21:00]</a>, allowing users to quickly verify a block's integrity by checking its root hash without downloading and re-executing the entire block <a class="yt-timestamp" data-t="17:26:00">[17:26:00]</a>.

However, traditional Ethereum clients (like Geth) use off-the-shelf databases (e.g., B-trees or LSM trees) to *store* the MPT <a class="yt-timestamp" data-t="16:48:00">[16:48:00]</a>. This creates an inefficiency: when traversing the logical MPT, the underlying database must perform "tree traversal within a tree traversal" <a class="yt-timestamp" data-t="19:20:00">[19:20:00]</a>, requiring 16 to 32 times more lookups per traversal <a class="yt-timestamp" data-t="19:36:00">[19:36:00]</a>.

[[Monad DB | Monad DB]] is a full rebuild of a database where the Merkle Patricia Try is the native way data is stored on disk <a class="yt-timestamp" data-t="19:42:00">[19:42:00]</a>. By removing this "tree indirection" <a class="yt-timestamp" data-t="19:50:00">[19:50:00]</a>, [[Monad DB | Monad DB]] makes state access significantly more efficient <a class="yt-timestamp" data-t="20:10:00">[20:10:00]</a>. Combined with asynchronous IO (using kernel technology like IOUring) <a class="yt-timestamp" data-t="20:58:00">[20:58:00]</a>, this allows parallel state access to feed the parallel execution engine <a class="yt-timestamp" data-t="21:10:00">[21:10:00]</a>, which is the "secret sauce" for effective parallel execution <a class="yt-timestamp" data-t="21:19:00">[21:19:00]</a>.