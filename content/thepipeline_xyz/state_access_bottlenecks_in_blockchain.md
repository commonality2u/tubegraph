---
title: State access bottlenecks in blockchain
videoId: vm6ByQsdstg
---

From: [[thepipeline_xyz]] <br/> 

The primary bottleneck preventing the Ethereum Virtual Machine (EVM) from scaling is **state access** <a class="yt-timestamp" data-t="03:33:00">[03:33:00]</a>, <a class="yt-timestamp" data-t="30:05:00">[30:05:00]</a>. This refers to the process of reading and writing data stored on the blockchain's state database, which typically resides on Solid-State Drives (SSDs) <a class="yt-timestamp" data-t="03:45:00">[03:45:00]</a>.

## The Problem with State Access

Even with advancements like [[parallel_execution_in_blockchain_technology | parallel execution in blockchain technology]] (often referred to as the parallel EVM), significant [[performance_and_scalability_of_blockchain_systems | performance gains]] are not achieved if the underlying state access remains inefficient <a class="yt-timestamp" data-t="03:18:00">[03:18:00]</a>. The actual bottleneck lies in how the state is accessed and managed <a class="yt-timestamp" data-t="03:30:00">[03:30:00]</a>.

Key issues contributing to this bottleneck include:
*   **High Latency of SSD Reads** A single read from an SSD can have a latency of 80 to 100 microseconds or more <a class="yt-timestamp" data-t="10:25:00">[10:25:00]</a>. This is orders of magnitude longer than the time it takes to execute a simple smart contract <a class="yt-timestamp" data-t="10:41:00">[10:41:00]</a>, <a class="yt-timestamp" data-t="10:44:00">[10:44:00]</a>.
*   **Sequential Reads and Cumulative Time** A single transaction often requires multiple sequential reads from the database, such as reading the sender's account, destination account, proxy accounts, and storage slots for ERC-20 balances or Uniswap data <a class="yt-timestamp" data-t="10:50:00">[10:50:00]</a>, <a class="yt-timestamp" data-t="11:02:00">[11:02:00]</a>, <a class="yt-timestamp" data-t="11:07:00">[11:07:00]</a>. When these reads are sequential, their cumulative time significantly prolongs transaction execution <a class="yt-timestamp" data-t="11:16:00">[11:16:00]</a>, <a class="yt-timestamp" data-t="11:28:00">[11:28:00]</a>, <a class="yt-timestamp" data-t="11:30:00">[11:30:00]</a>.
*   **Lack of Parallel Access Support** Databases currently used by Ethereum and other EVM-compatible blockchains to store state do not inherently support parallel access <a class="yt-timestamp" data-t="03:58:00">[03:58:00]</a>, <a class="yt-timestamp" data-t="04:02:00">[04:02:00]</a>. This means that even if multiple virtual machines are running in parallel, they still bottleneck when making reads to the database, effectively resulting in single-file execution <a class="yt-timestamp" data-t="04:05:00">[04:05:00]</a>, <a class="yt-timestamp" data-t="04:08:00">[04:08:00]</a>, <a class="yt-timestamp" data-t="04:13:00">[04:13:00]</a>.
*   **Inefficient General-Purpose Databases** Many blockchain clients utilize general-purpose databases like PebbleDB, RocksDB, LevelDB (LSM trees), LMDB, or MDBX (B+ tree databases) <a class="yt-timestamp" data-t="08:53:00">[08:53:00]</a>, <a class="yt-timestamp" data-t="13:14:00">[13:14:00]</a>, <a class="yt-timestamp" data-t="13:21:00">[13:21:00]</a>, <a class="yt-timestamp" data-t="13:24:00">[13:24:00]</a>. These databases are not optimized for the specific data access patterns of blockchains <a class="yt-timestamp" data-t="13:34:00">[13:34:00]</a>, <a class="yt-timestamp" data-t="13:50:00">[13:50:00]</a>.
*   **Nested Data Structures** Ethereum's database design embeds one data structure inside another, meaning every request involves traversing two data structures, which is an expensive operation <a class="yt-timestamp" data-t="12:53:00">[12:53:00]</a>, <a class="yt-timestamp" data-t="13:03:00">[13:03:00]</a>, <a class="yt-timestamp" data-t="13:07:00">[13:07:00]</a>.
*   **Over-reliance on RAM** A "shortcut" to mitigate state access latency is to simply require large amounts of RAM <a class="yt-timestamp" data-t="11:37:00">[11:37:00]</a>, <a class="yt-timestamp" data-t="50:21:00">[50:21:00]</a>. However, this is significantly more expensive (RAM is two orders of magnitude costlier than SSDs for the same storage capacity) <a class="yt-timestamp" data-t="50:32:00">[50:32:00]</a>, does not scale well over time as state grows <a class="yt-timestamp" data-t="51:00:00">[51:00:00]</a>, and compromises decentralization by increasing hardware requirements for participants <a class="yt-timestamp" data-t="51:29:00">[51:29:00]</a>.

## Monad's Approach to State Access Optimization

Monad Labs identified state access as the primary bottleneck over a year and a half ago, after finding that [[parallel_execution_in_blockchain_technology | optimistic parallel execution]] alone yielded minimal performance improvement <a class="yt-timestamp" data-t="03:11:00">[03:11:00]</a>, <a class="yt-timestamp" data-t="04:17:00">[04:17:00]</a>. Their solution was to develop a **custom state database** tailored specifically for blockchain use cases <a class="yt-timestamp" data-t="08:31:00">[08:31:00]</a>, <a class="yt-timestamp" data-t="09:03:00">[09:03:00]</a>.

This approach is inspired by their background in High-Frequency Trading (HFT), where building highly performant systems from the ground up, avoiding standard libraries, and optimizing at the lowest levels (e.g., assembly instructions) is critical for shaving off latency <a class="yt-timestamp" data-t="05:25:00">[05:25:00]</a>, <a class="yt-timestamp" data-t="06:06:00">[06:06:00]</a>, <a class="yt-timestamp" data-t="13:55:00">[13:55:00]</a>, <a class="yt-timestamp" data-t="30:53:00">[30:53:00]</a>.

Key aspects of Monad's solution:
*   **Custom Database for Optimized Access** Monad's database is designed knowing exactly how data is stored and accessed, allowing for significant optimization over general-purpose databases <a class="yt-timestamp" data-t="14:17:00">[14:17:00]</a>, <a class="yt-timestamp" data-t="14:20:00">[14:20:00]</a>, <a class="yt-timestamp" data-t="14:30:00">[14:30:00]</a>. This means performing fewer requests to the underlying hardware (e.g., 1-2 requests to look up an account in Monad's database versus potentially 20 requests in other data structures when not cached) <a class="yt-timestamp" data-t="16:46:00">[16:46:00]</a>, <a class="yt-timestamp" data-t="16:54:00">[16:54:00]</a>.
*   **Leveraging Modern SSD Capabilities** Modern SSDs are highly performant, capable of 500,000 I/O operations per second (IOPS) <a class="yt-timestamp" data-t="12:09:00">[12:09:00]</a>, <a class="yt-timestamp" data-t="15:10:00">[15:10:00]</a>, <a class="yt-timestamp" data-t="15:16:00">[15:16:00]</a>, <a class="yt-timestamp" data-t="15:46:00">[15:46:00]</a>. Monad's custom database is built to fully extract this capability from commodity hardware, rather than just throwing more RAM at the problem <a class="yt-timestamp" data-t="12:02:00">[12:02:00]</a>, <a class="yt-timestamp" data-t="21:05:00">[21:05:00]</a>, <a class="yt-timestamp" data-t="21:11:00">[21:11:00]</a>, <a class="yt-timestamp" data-t="21:13:00">[21:13:00]</a>, <a class="yt-timestamp" data-t="21:16:00">[21:16:00]</a>.
*   **Holistic Optimization Approach** Monad's [[optimizing_blockchain_performance | performance optimization]] is not just about [[parallel_execution_in_blockchain_technology | parallel execution]] or the database, but a combination of many specific, highly focused optimizations that add up to significant speedups <a class="yt-timestamp" data-t="04:47:00">[04:47:00]</a>, <a class="yt-timestamp" data-t="04:49:00">[04:49:00]</a>, <a class="yt-timestamp" data-t="15:19:00">[15:19:00]</a>, <a class="yt-timestamp" data-t="30:11:00">[30:11:00]</a>, <a class="yt-timestamp" data-t="31:10:00">[31:10:00]</a>, <a class="yt-timestamp" data-t="33:15:00">[33:15:00]</a>. This includes micro-optimizations like translating virtual to physical addresses for TLB (Translation Lookaside Buffer) <a class="yt-timestamp" data-t="30:18:00">[30:18:00]</a>, <a class="yt-timestamp" data-t="30:20:00">[30:20:00]</a>.

By taking this "no shortcuts" approach, Monad aims to build a blockchain that can handle the scale required for broader adoption, supporting scenarios like fully on-chain limit order books with sub-cent fees and thousands of orders per second <a class="yt-timestamp" data-t="28:33:00">[28:33:00]</a>, <a class="yt-timestamp" data-t="28:41:00">[28:41:00]</a>, <a class="yt-timestamp" data-t="28:47:00">[28:47:00]</a>. This also ties into the [[need_for_performant_blockchains | need for performant blockchains]] and [[the_importance_of_high_throughput_blockchains | high throughput blockchains]] to bridge the gap between traditional finance volumes and DeFi <a class="yt-timestamp" data-t="27:31:00">[27:31:00]</a>, <a class="yt-timestamp" data-t="27:51:00">[27:51:00]</a>.