---
title: Unique database optimizations in blockchains
videoId: vm6ByQsdstg
---

From: [[thepipeline_xyz]] <br/> 

Monad Labs, founded by Keone and James who previously worked together at Jump Trading and Jump Crypto, is focused on achieving true [[blockchain performance optimization | performance gains]] in the crypto space <a class="yt-timestamp" data-t="00:06:00">[00:06:00]</a> <a class="yt-timestamp" data-t="00:13:00">[00:13:00]</a>. While the [[parallel execution in blockchain | parallel EVM]] has become a significant narrative, Monad Labs emphasizes that this alone is not sufficient for optimal [[high performance blockchains | performance]] <a class="yt-timestamp" data-t="00:24:00">[00:24:00]</a> <a class="yt-timestamp" data-t="00:40:00">[00:40:00]</a> <a class="yt-timestamp" data-t="08:05:00">[08:05:00]</a>. The real key lies in deeper, more fundamental [[optimization strategies for blockchain clients | optimizations]], particularly at the state database level <a class="yt-timestamp" data-t="04:47:00">[04:47:00]</a> <a class="yt-timestamp" data-t="04:51:00">[04:51:00]</a>.

## The Bottleneck of State Access
Monad pushed the first [[parallel execution in blockchain | parallel EVM]] algorithm over 1.5 years ago, known as optimistic parallel execution <a class="yt-timestamp" data-t="01:16:00">[01:16:00]</a> <a class="yt-timestamp" data-t="01:34:00">[01:34:00]</a>. In this approach, transactions are linearly ordered within a block and run in parallel, generating pending results with input/output records <a class="yt-timestamp" data-t="01:39:00">[01:39:00]</a> <a class="yt-timestamp" data-t="02:02:00">[02:02:00]</a>. These results are committed in original order, and if an input is invalidated, the work is rescheduled <a class="yt-timestamp" data-t="02:15:00">[02:15:00]</a> <a class="yt-timestamp" data-t="02:22:00">[02:22:00]</a>. Re-execution due to conflicts is typically cheap as inputs are often cached <a class="yt-timestamp" data-t="02:47:00">[02:47:00]</a> <a class="yt-timestamp" data-t="02:55:00">[02:55:00]</a>.

However, Monad Labs found that [[parallel execution in blockchain | parallel execution]] alone yielded minimal improvement <a class="yt-timestamp" data-t="03:11:00">[03:11:00]</a> <a class="yt-timestamp" data-t="03:18:00">[03:18:00]</a>. The core reason for this [[challenges of standard databases in blockchain performance | bottleneck]] is state access <a class="yt-timestamp" data-t="03:30:00">[03:30:00]</a>. Each transaction has dependencies on accounts and slots stored on an SSD <a class="yt-timestamp" data-t="03:35:00">[03:35:00]</a>. The cost of reading from an SSD is significant, and standard databases used by Ethereum and other EVM-compatible blockchains do not support parallel access <a class="yt-timestamp" data-t="03:45:00">[03:45:00]</a> <a class="yt-timestamp" data-t="03:57:00">[03:57:00]</a>. This means multiple virtual machines running in parallel still bottleneck at the database, effectively resulting in single-file execution <a class="yt-timestamp" data-t="04:05:00">[04:05:00]</a> <a class="yt-timestamp" data-t="04:15:00">[04:15:00]</a>. The most expensive parts of a blockchain are cryptography functions, hashing, and state access <a class="yt-timestamp" data-t="09:06:00">[09:06:00]</a>. Paralyzing computation by itself doesn't offer much gain <a class="yt-timestamp" data-t="09:44:00">[09:44:00]</a>.

A single read from an SSD can take 80-100 microseconds or more, which is orders of magnitude longer than executing a simple smart contract <a class="yt-timestamp" data-t="10:23:00">[10:23:00]</a> <a class="yt-timestamp" data-t="10:41:00">[10:41:00]</a>. Sequential reads for sender accounts, destination accounts, proxy accounts, and storage slots (like ERC-20 balances or Uniswap data) add up to significant transaction execution times <a class="yt-timestamp" data-t="10:52:00">[10:52:00]</a> <a class="yt-timestamp" data-t="11:14:00">[11:14:12]</a>.

## Limitations of Standard Databases
Standard databases like Pebble DB, RocksDB (an LSM tree), LMDB, and MDBX (B+ tree databases) are general-purpose databases <a class="yt-timestamp" data-t="13:13:00">[13:13:00]</a> <a class="yt-timestamp" data-t="13:21:00">[13:21:00]</a>. They are designed for average performance rather than specialized, [[blockchain performance optimization | high-performance]] tasks <a class="yt-timestamp" data-t="13:48:00">[13:48:00]</a>. Many blockchain clients using these databases exhibit terrible performance, despite the impressive capabilities of modern SSDs (e.g., 500,000 I/O operations per second for a $200 SSD) <a class="yt-timestamp" data-t="12:09:00">[12:09:00]</a> <a class="yt-timestamp" data-t="12:25:00">[12:25:00]</a> <a class="yt-timestamp" data-t="13:37:00">[13:37:00]</a> <a class="yt-timestamp" data-t="15:39:00">[15:39:00]</a>. A primary issue with these general-purpose databases in blockchain contexts is that they often involve embedding one data structure inside another on disk, making every request traverse two data structures, which is an expensive operation <a class="yt-timestamp" data-t="12:51:00">[12:51:00]</a> <a class="yt-timestamp" data-t="13:05:00">[13:05:00]</a>. Additionally, they often make many requests for basic lookups <a class="yt-timestamp" data-t="16:27:00">[16:27:00]</a>.

## Monad DB: A Custom Solution
Recognizing these [[challenges of standard databases in blockchain performance | limitations]], Monad Labs began developing its own custom database, the [[monad_db_and_its_role_in_efficient_blockchain_operations | Monad database]] <a class="yt-timestamp" data-t="04:28:00">[04:28:00]</a> <a class="yt-timestamp" data-t="14:29:00">[14:29:00]</a>. This approach was inspired by their high-frequency trading (HFT) background at Jump Trading, where custom data structures were essential for shaving off latency and building performant systems <a class="yt-timestamp" data-t="05:16:00">[05:16:00]</a> <a class="yt-timestamp" data-t="06:06:00">[06:06:00]</a> <a class="yt-timestamp" data-t="13:55:00">[13:55:00]</a>. In HFT, standard libraries are avoided because they are not optimized for specific trading models, whereas customized data structures can extract significantly better [[blockchain performance optimization | performance]] from hardware <a class="yt-timestamp" data-t="13:59:00">[13:59:00]</a> <a class="yt-timestamp" data-t="14:08:00">[14:08:00]</a>.

The [[monad_db_and_its_role_in_efficient_blockchain_operations | Monad database]] is designed with a precise understanding of how data will be used and stored within the blockchain <a class="yt-timestamp" data-t="14:17:00">[14:17:00]</a> <a class="yt-timestamp" data-t="14:24:00">[14:24:00]</a>. This custom-tailored design means that [[monad_db_and_its_role_in_efficient_blockchain_operations | Monad DB]] can perform lookups with significantly fewer requests to the hardware (e.g., one or two requests to look up an account compared to 20 for other data structures not in cache) <a class="yt-timestamp" data-t="16:43:00">[16:43:00]</a> <a class="yt-timestamp" data-t="16:51:00">[16:51:00]</a>. This "super optimization" extracts every last bit of performance from the hardware <a class="yt-timestamp" data-t="16:59:00">[16:59:00]</a> <a class="yt-timestamp" data-t="17:01:00">[17:01:00]</a>.

## The "No Shortcuts" Philosophy
The tagline "no shortcuts" embodies Monad's development philosophy <a class="yt-timestamp" data-t="20:35:00">[20:35:00]</a>. This means a commitment to running on commodity hardware while extracting maximum performance, rather than simply "throwing hardware at it" by requiring expensive, very large RAM boxes <a class="yt-timestamp" data-t="11:37:00">[11:37:00]</a> <a class="yt-timestamp" data-t="21:03:00">[21:03:00]</a> <a class="yt-timestamp" data-t="21:11:00">[21:11:00]</a>. While some projects aim for Raspberry Pi compatibility, Monad targets the capabilities of a modern $200 SSD <a class="yt-timestamp" data-t="21:48:00">[21:48:00]</a> <a class="yt-timestamp" data-t="21:51:00">[21:51:00]</a> <a class="yt-timestamp" data-t="21:55:00">[21:55:00]</a>.

The development process involves deep understanding, extensive experimentation, and a quantitative approach <a class="yt-timestamp" data-t="23:37:00">[23:37:00]</a> <a class="yt-timestamp" data-t="23:39:00">[23:39:00]</a>. This includes micro-optimizations, such as optimizing translation lookaside buffers for a 5% gain <a class="yt-timestamp" data-t="30:09:00">[30:09:00]</a> <a class="yt-timestamp" data-t="30:15:00">[30:15:00]</a> <a class="yt-timestamp" data-t="30:31:00">[30:31:00]</a>. They analyze assembly instructions and continuously measure performance, avoiding assumptions that sound intuitive but may not be optimal (e.g., the potential counterproductiveness of access lists for performance) <a class="yt-timestamp" data-t="30:53:00">[30:53:00]</a> <a class="yt-timestamp" data-t="31:01:00">[31:01:00]</a> <a class="yt-timestamp" data-t="31:20:00">[31:20:00]</a> <a class="yt-timestamp" data-t="32:01:00">[32:01:00]</a>. This rigorous, iterative process often involves writing and discarding code, which takes significant time <a class="yt-timestamp" data-t="23:45:00">[23:45:00]</a> <a class="yt-timestamp" data-t="24:23:00">[24:23:00]</a> <a class="yt-timestamp" data-t="34:36:00">[34:36:00]</a>.

A common "shortcut" for [[blockchain scalability and highperformance systems | scaling]] is to simply increase RAM requirements <a class="yt-timestamp" data-t="50:21:00">[50:21:00]</a>. However, RAM is two orders of magnitude more expensive than SSDs ($20,000 for 2 terabytes of RAM vs. $200 for a 2 terabyte NVMe SSD) <a class="yt-timestamp" data-t="50:32:00">[50:32:00]</a> <a class="yt-timestamp" data-t="50:53:00">[50:53:00]</a>. This approach doesn't scale well and undermines decentralization by making it harder for regular people to participate in the network due to high hardware costs <a class="yt-timestamp" data-t="17:17:00">[17:17:00]</a> <a class="yt-timestamp" data-t="21:17:00">[21:17:00]</a> <a class="yt-timestamp" data-t="21:24:00">[21:24:00]</a> <a class="yt-timestamp" data-t="51:29:00">[51:29:00]</a>.

## Benchmarking and Transparency
To provide accurate information and move beyond marketing hype, Monad Labs stresses the importance of standardized benchmarks for [[discussion on high throughput blockchains | blockchain performance]] <a class="yt-timestamp" data-t="44:09:00">[44:09:00]</a> <a class="yt-timestamp" data-t="44:54:00">[44:54:00]</a> <a class="yt-timestamp" data-t="45:00:00">[45:00:00]</a>. Internally, they use replaying recent Ethereum history as their benchmark <a class="yt-timestamp" data-t="45:08:00">[45:08:00]</a> <a class="yt-timestamp" data-t="46:20:00">[46:20:00]</a>. They aim to release a publicly available GitHub repository where others can download and replicate benchmarks from Monad and other chains <a class="yt-timestamp" data-t="46:24:00">[46:24:00]</a> <a class="yt-timestamp" data-t="46:27:00">[46:27:00]</a>. This transparency and rigor, similar to scientific papers that allow for replication, would improve the engineering standards of the industry <a class="yt-timestamp" data-t="49:00:00">[49:00:00]</a> <a class="yt-timestamp" data-t="49:10:00">[49:10:00]</a> <a class="yt-timestamp" data-t="49:32:00">[49:32:00]</a>.

Benchmarking must provide context for TPS (transactions per second) numbers, differentiating between simple token transfers (where even unoptimized clients can achieve 50k TPS) and complex operations like Uniswap or borrowing protocol transactions <a class="yt-timestamp" data-t="45:31:00">[45:31:00]</a> <a class="yt-timestamp" data-t="45:55:00">[45:55:00]</a>.

## Impact on EVM Scaling
Monad's work contributes meaningfully to Ethereum by exploring a new, orthogonal direction: rebuilding the execution stack from the ground up, researching custom databases, and implementing [[parallel execution in blockchain | parallel]] and asynchronous execution <a class="yt-timestamp" data-t="53:40:00">[53:40:00]</a> <a class="yt-timestamp" data-t="53:45:00">[53:45:00]</a> <a class="yt-timestamp" data-t="53:50:00">[53:50:00]</a>. The EVM is a powerful bytecode standard with rich tooling, and Monad leverages this existing foundation while pushing the boundaries of what's possible <a class="yt-timestamp" data-t="54:24:00">[54:24:00]</a> <a class="yt-timestamp" data-t="54:36:00">[54:36:00]</a>. These deep, focused optimizations aim to address the fundamental [[blockchain scalability and highperformance systems | scaling]] challenges of the EVM, allowing for greater throughput and lower latency for users <a class="yt-timestamp" data-t="33:03:00">[33:03:00]</a> <a class="yt-timestamp" data-t="40:00:00">[40:00:00]</a> <a class="yt-timestamp" data-t="40:51:00">[40:51:00]</a>.