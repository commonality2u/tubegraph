---
title: Importance of Custom State Databases in Blockchain
videoId: VfUdVfIg7JI
---

From: [[thepipeline_xyz]] <br/> 

Developing a [[custom_state_database_development_by_manad | custom state database]] is crucial for achieving high performance in EVM (Ethereum Virtual Machine) implementations and addressing the specific [[challenges_in_blockchain_system_design | challenges in blockchain system design]] <a class="yt-timestamp" data-t="00:00:15">[00:00:15]</a> <a class="yt-timestamp" data-t="00:00:17">[00:00:17]</a>. Standard databases like Pebble DB or RocksDB are often insufficient for the unique demands of blockchain environments <a class="yt-timestamp" data-t="00:00:09">[00:00:09]</a>.

## Key Performance Bottlenecks in Blockchain

The most expensive operations in blockchain are:
*   **Cryptography functions** such as elliptical curve cryptography and hashing <a class="yt-timestamp" data-t="00:00:24">[00:00:24]</a> <a class="yt-timestamp" data-t="00:00:27">[00:00:27]</a>.
*   **State access** <a class="yt-timestamp" data-t="00:00:35">[00:00:35]</a>.

In contrast, the business logic within most smart contracts is relatively "cheap" to execute compared to typical desktop or phone applications, meaning raw computation itself doesn't offer significant gains <a class="yt-timestamp" data-t="00:00:41">[00:00:41]</a> <a class="yt-timestamp" data-t="00:00:55">[00:00:55]</a> <a class="yt-timestamp" data-t="00:01:00">[00:01:00]</a>. While some clients already incorporate parallel signature recovery, which is an expensive part of transaction execution, there isn't much more to gain in that area <a class="yt-timestamp" data-t="00:01:05">[00:01:05]</a> <a class="yt-timestamp" data-t="00:01:09">[00:01:09]</a> <a class="yt-timestamp" data-t="00:01:17">[00:01:17]</a>.

Instead, the primary bottleneck often lies in database interactions. A single read from an SSD can have a latency of 80 to 100 microseconds or more <a class="yt-timestamp" data-t="00:01:38">[00:01:38]</a> <a class="yt-timestamp" data-t="00:01:40">[00:01:40]</a> <a class="yt-timestamp" data-t="00:01:45">[00:01:45]</a>. This is orders of magnitude longer than it takes to execute a simple smart contract <a class="yt-timestamp" data-t="00:01:56">[00:01:56]</a> <a class="yt-timestamp" data-t="00:01:59">[00:01:59]</a>.

## Inefficiencies of General-Purpose Databases

Blockchain clients often make multiple sequential database reads for a single transaction, such as:
*   Reading the sender's account to check balance <a class="yt-timestamp" data-t="00:02:07">[00:02:07]</a> <a class="yt-timestamp" data-t="00:02:08">[00:02:08]</a>.
*   Reading the destination account <a class="yt-timestamp" data-t="00:02:11">[00:02:11]</a>.
*   Reading proxy accounts <a class="yt-timestamp" data-t="00:02:13">[00:02:13]</a> <a class="yt-timestamp" data-t="00:02:15">[00:02:15]</a>.
*   Reading storage slots (e.g., ERC20 token balances or Uniswap data) <a class="yt-timestamp" data-t="00:02:17">[00:02:17]</a> <a class="yt-timestamp" data-t="00:02:19">[00:02:19]</a> <a class="yt-timestamp" data-t="00:02:22">[00:02:22]</a> <a class="yt-timestamp" data-t="00:02:23">[00:02:23]</a> <a class="yt-timestamp" data-t="00:02:25">[00:02:25]</a>.

If these reads are not cached in main memory and must hit the disk, the cumulative latency can significantly prolong transaction execution time <a class="yt-timestamp" data-t="00:02:30">[00:02:30]</a> <a class="yt-timestamp" data-t="00:02:33">[00:02:33]</a> <a class="yt-timestamp" data-t="00:02:36">[00:02:36]</a> <a class="yt-timestamp" data-t="00:02:39">[00:02:39]</a> <a class="yt-timestamp" data-t="00:02:41">[00:02:41]</a> <a class="yt-timestamp" data-t="00:02:43">[00:02:43]</a> <a class="yt-timestamp" data-t="00:02:45">[00:02:45]</a>.

While one solution is to simply "throw RAM at it" by requiring expensive, large-memory servers to minimize disk reads <a class="yt-timestamp" data-t="00:02:53">[00:02:53]</a> <a class="yt-timestamp" data-t="00:02:54">[00:02:54]</a> <a class="yt-timestamp" data-t="00:02:56">[00:02:56]</a>, this approach does not address the fundamental inefficiencies.

Standard databases commonly used in blockchain clients, such as:
*   **B+ tree databases**: LMDB and MDBX (an LMDB derivative) <a class="yt-timestamp" data-t="00:04:30">[00:04:30]</a> <a class="yt-timestamp" data-t="00:04:33">[00:04:33]</a> <a class="yt-timestamp" data-t="00:04:37">[00:04:37]</a>.
*   **LSM (Log-Structured Merge) trees**: RocksDB and LevelDB <a class="yt-timestamp" data-t="00:04:37">[00:04:37]</a> <a class="yt-timestamp" data-t="00:04:40">[00:04:40]</a> <a class="yt-timestamp" data-t="00:04:43">[00:04:43]</a>.

These are general-purpose databases designed for average performance <a class="yt-timestamp" data-t="00:04:50">[00:04:50]</a> <a class="yt-timestamp" data-t="00:04:51">[00:04:51]</a> <a class="yt-timestamp" data-t="00:04:54">[00:04:54]</a> <a class="yt-timestamp" data-t="00:05:05">[00:05:05]</a>. A key issue with some implementations, like Geth, is embedding one data structure inside another on disk, leading to expensive double-traversal for every request <a class="yt-timestamp" data-t="00:04:06">[00:04:06]</a> <a class="yt-timestamp" data-t="00:04:09">[00:04:09]</a> <a class="yt-timestamp" data-t="00:04:10">[00:04:10]</a> <a class="yt-timestamp" data-t="00:04:13">[00:04:13]</a> <a class="yt-timestamp" data-t="00:04:14">[00:04:14]</a> <a class="yt-timestamp" data-t="00:04:18">[00:04:18]</a> <a class="yt-timestamp" data-t="00:04:20">[00:04:20]</a> <a class="yt-timestamp" data-t="00:04:22">[00:04:22]</a>.

## The Advantage of Customization

Modern SSDs are incredibly powerful, capable of 500,000 I/O operations per second <a class="yt-timestamp" data-t="00:06:53">[00:06:53]</a> <a class="yt-timestamp" data-t="00:06:54">[00:06:54]</a> <a class="yt-timestamp" data-t="00:06:56">[00:06:56]</a> <a class="yt-timestamp" data-t="00:06:58">[00:06:58]</a> <a class="yt-timestamp" data-t="00:07:01">[00:07:01]</a>. However, this raw performance is wasted if the software isn't optimized to leverage it <a class="yt-timestamp" data-t="00:07:04">[00:07:04]</a> <a class="yt-timestamp" data-t="00:07:07">[00:07:07]</a> <a class="yt-timestamp" data-t="00:07:10">[00:07:10]</a>. Even an algorithm with better computational complexity will perform poorly if implemented inefficiently <a class="yt-timestamp" data-t="00:07:12">[00:07:12]</a> <a class="yt-timestamp" data-t="00:07:13">[00:07:13]</a> <a class="yt-timestamp" data-t="00:07:16">[00:07:16]</a> <a class="yt-timestamp" data-t="00:07:19">[00:07:19]</a>.

This concept is well-understood in high-frequency trading (HFT), where standard libraries are avoided because custom data structures, tailored to the specific trading model, yield significantly better performance from the hardware <a class="yt-timestamp" data-t="00:05:10">[00:05:10]</a> <a class="yt-timestamp" data-t="00:05:12">[00:05:12]</a> <a class="yt-timestamp" data-t="00:05:14">[00:05:14]</a> <a class="yt-timestamp" data-t="00:05:17">[00:05:17]</a> <a class="yt-timestamp" data-t="00:05:19">[00:05:19]</a> <a class="yt-timestamp" data-t="00:05:20">[00:05:20]</a> <a class="yt-timestamp" data-t="00:05:23">[00:05:23]</a> <a class="yt-timestamp" data-t="00:05:26">[00:05:26]</a> <a class="yt-timestamp" data-t="00:05:29">[00:05:29]</a>.

Applying this principle to blockchain, a [[custom_state_database_development_by_manad | custom database]] like Manad DB is designed with precise knowledge of how data will be used and stored <a class="yt-timestamp" data-t="00:05:32">[00:05:32]</a> <a class="yt-timestamp" data-t="00:05:36">[00:05:36]</a> <a class="yt-timestamp" data-t="00:05:40">[00:05:40]</a> <a class="yt-timestamp" data-t="00:05:42">[00:05:42]</a>. This allows for "super optimization" to extract every last bit of [[need_for_performant_blockchain | performance]] <a class="yt-timestamp" data-t="00:08:14">[00:08:14]</a> <a class="yt-timestamp" data-t="00:08:16">[00:08:16]</a> <a class="yt-timestamp" data-t="00:08:18">[00:08:18]</a>.

For example, Manad DB might require only one or two requests to look up an account, whereas other general-purpose data structures could require 20 requests to the hardware if the data is not cached <a class="yt-timestamp" data-t="00:07:42">[00:07:42]</a> <a class="yt-timestamp" data-t="00:07:44">[00:07:44]</a> <a class="yt-timestamp" data-t="00:07:47">[00:07:47]</a> <a class="yt-timestamp" data-t="00:07:50">[00:07:50]</a> <a class="yt-timestamp" data-t="00:07:59">[00:07:59]</a> <a class="yt-timestamp" data-t="00:08:02">[00:08:02]</a> <a class="yt-timestamp" data-t="00:08:06">[00:08:06]</a> <a class="yt-timestamp" data-t="00:08:07">[00:08:07]</a> <a class="yt-timestamp" data-t="00:08:09">[00:08:09]</a> <a class="yt-timestamp" data-t="00:08:11">[00:08:11]</a>. This significant reduction in disk I/O requests leads to massive [[scaling_blockchain_ecosystems | performance gains]] and is why [[custom_state_database_development_by_manad | custom state database development]] is critical for [[need_for_performant_blockchain | performant blockchain]] ecosystems <a class="yt-timestamp" data-t="00:06:31">[00:06:31]</a> <a class="yt-timestamp" data-t="00:06:34">[00:06:34]</a> <a class="yt-timestamp" data-t="00:06:36">[00:06:36]</a>.