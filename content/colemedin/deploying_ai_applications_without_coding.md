---
title: Deploying AI Applications Without Coding
videoId: JyolNYRbAcs
---

From: [[colemedin]] <br/> 

Many individuals are leveraging n8n to build AI agents, making it a highly popular tool due to its ease of use for creating simple yet powerful AI agents without requiring extensive coding <a class="yt-timestamp" data-t="00:00:12">[00:00:12]</a>. However, building an agent with n8n typically isn't sufficient on its own; a front end is often necessary for users to interact with the agent cleanly and simply <a class="yt-timestamp" data-t="00:00:23">[00:00:23]</a>. While n8n offers a chat widget, it often lacks the features needed for a good user experience <a class="yt-timestamp" data-t="00:00:33">[00:00:33]</a>.

This article outlines how to [[building_and_deploying_custom_ai_front_ends | build custom, secure interfaces]] for AI agents using a specific combination of tools, allowing for creation and [[deploying_and_testing_ai_agents_quickly | deployment in as little as an afternoon]] <a class="yt-timestamp" data-t="00:00:45">[00:00:45]</a>. This approach avoids the need for full React or Next.js projects and minimizes coding, as an LLM (Large Language Model) like Claude handles the code generation <a class="yt-timestamp" data-t="00:00:56">[00:00:56]</a>.

## Recommended Tool Combination
The preferred combination for rapid AI application deployment includes:
*   **Claude**: An LLM known for its strong coding abilities, particularly with Streamlit <a class="yt-timestamp" data-t="00:01:28">[00:01:28]</a>.
*   **Streamlit**: A Python package that simplifies website development without JavaScript <a class="yt-timestamp" data-t="00:01:22">[00:01:22]</a>.
*   **Supabase**: Provides easy authentication and is commonly used with n8n agents for features like chat memory and Retrieval-Augmented Generation (RAG) <a class="yt-timestamp" data-t="00:01:45">[00:01:45]</a>.

## Building a Basic Streamlit Interface with Claude

The process begins by instructing Claude to generate a basic Streamlit application with a chat interface designed to communicate with an LLM <a class="yt-timestamp" data-t="00:02:13">[00:02:13]</a>. It is crucial to specify the expected interaction format, including how to chat with the LLM and how the webhook should be utilized <a class="yt-timestamp" data-t="00:02:45">[00:02:45]</a>.

For initial protection, a hardcoded bearer token can be used for basic authentication, though this is not recommended for production environments <a class="yt-timestamp" data-t="00:02:56">[00:02:56]</a>. The webhook, which is a POST request, requires specific payload items: a `session ID` for chat history and `chat input` for the user's prompt <a class="yt-timestamp" data-t="00:03:31">[00:03:31]</a>. Claude also needs to be informed that the LLM's response is contained within an `output` key in the JSON response <a class="yt-timestamp" data-t="00:03:41">[00:03:41]</a>.

Claude rapidly generates the necessary Python code <a class="yt-timestamp" data-t="00:03:49">[00:03:49]</a>. The generated code includes:
*   A function to send requests to the LLM and retrieve responses.
*   The main function to set up the Streamlit user interface with chat input.
*   Functionality to add user input to the UI, get an LLM response, and display it <a class="yt-timestamp" data-t="00:04:26">[00:04:26]</a>.

### N8N Workflow Setup for Front End

To integrate the n8n agent with the Streamlit front end via a webhook, specific configurations are required within the n8n workflow <a class="yt-timestamp" data-t="00:04:59">[00:04:59]</a>.

#### Webhook Trigger
*   Add a **Webhook Trigger** node at the beginning of the workflow <a class="yt-timestamp" data-t="00:05:34">[00:05:34]</a>.
*   The production URL for this webhook will be active as long as the n8n workflow is active <a class="yt-timestamp" data-t="00:06:01">[00:06:01]</a>. This URL fills a placeholder in the Python code generated by Claude <a class="yt-timestamp" data-t="00:06:07">[00:06:07]</a>.
*   For basic authentication, select "Header Auth" and set the credential name to "Authorization" <a class="yt-timestamp" data-t="00:06:29">[00:06:29]</a>. The value should be `Bearer <Your_Token_Name>` (e.g., `Bearer mysecrettoken`) <a class="yt-timestamp" data-t="00:06:40">[00:06:40]</a>.
*   Configure the webhook to respond using a "Respond to Webhook" node, rather than immediately <a class="yt-timestamp" data-t="00:07:01">[00:07:01]</a>. This node, by default, returns output items from the preceding node, including the `output` key from the LLM <a class="yt-timestamp" data-t="00:07:10">[00:07:10]</a>.

#### Payload Handling
The n8n workflow expects `session ID` and `chat input` in the payload <a class="yt-timestamp" data-t="00:07:36">[00:07:36]</a>. These values are extracted from the webhook's JSON body (`json.body.chat input` and `json.body.session ID`) and used for chat history and user prompts, respectively <a class="yt-timestamp" data-t="00:07:59">[00:07:59]</a>. This setup allows the workflow to function correctly whether triggered by the chat widget or the webhook <a class="yt-timestamp" data-t="00:08:06">[00:08:06]</a>.

### Running the Streamlit App
Once the Python code is copied into a Visual Studio Code IDE and placeholder values (webhook URL, bearer token) are filled in <a class="yt-timestamp" data-t="00:09:09">[00:09:09]</a>, the Streamlit app can be run. Required Python packages can be installed via `pip install -r requirements.txt` <a class="yt-timestamp" data-t="00:09:41">[00:09:41]</a>.

To run the script, navigate to its directory in the terminal and execute `streamlit run <script_name>.py` <a class="yt-timestamp" data-t="00:09:56">[00:09:56]</a>. This command instantly opens the Streamlit application in a browser, providing a simple chat interface for the AI agent <a class="yt-timestamp" data-t="00:10:03">[00:10:03]</a>.

## Adding Supabase Authentication for Robust Security

To enhance the application's security and robustness, Supabase authentication is integrated into both the Streamlit front end and the n8n backend <a class="yt-timestamp" data-t="00:10:52">[00:10:52]</a>.

### Updating Streamlit with Claude
The next step involves prompting Claude to update the existing Streamlit app to incorporate Supabase for authentication. Key instructions for Claude include:
*   Implementing both login and signup functionalities <a class="yt-timestamp" data-t="00:11:13">[00:11:13]</a>.
*   Using the user's Supabase token as the bearer token for the n8n webhook <a class="yt-timestamp" data-t="00:11:22">[00:11:22]</a>. This token is dynamically generated by the Supabase Python library upon successful sign-in <a class="yt-timestamp" data-t="00:11:30">[00:11:30]</a>.
*   Displaying user information, such as the email, in a left-side panel to demonstrate robustness <a class="yt-timestamp" data-t="00:12:02">[00:12:02]</a>.
*   Cautioning Claude against using deprecated features to prevent hallucinations <a class="yt-timestamp" data-t="00:12:08">[00:12:08]</a>.

Claude generates an updated, more robust Streamlit code <a class="yt-timestamp" data-t="00:12:19">[00:12:19]</a>. After a user signs in, their user object (containing the token) is added to the session state, allowing the `access token` attribute to be dynamically retrieved and passed as a bearer token to n8n <a class="yt-timestamp" data-t="00:12:54">[00:12:54]</a>.

### Updating N8N Workflow for Supabase Authentication

To work with the new user-specific Supabase bearer token, the n8n workflow needs modifications:
1.  **Disable Webhook Authentication**: Turn off the authentication setting in the Webhook Trigger node, as manual handling of the Supabase token will be performed in a subsequent step <a class="yt-timestamp" data-t="00:13:42">[00:13:42]</a>.
2.  **Retrieve Supabase Credentials**: Obtain the Superbase Project URL and the **Service Role Secret (API Key)** from the Superbase API settings (<a class="yt-timestamp" data-t="00:14:14">[00:14:14]</a> Project Settings > API) <a class="yt-timestamp" data-t="00:14:04">[00:14:04]</a>. The **Anonymous API Key** is public and can be used in the Streamlit UI, provided row-level security is defined on tables <a class="yt-timestamp" data-t="00:14:32">[00:14:32]</a>.
3.  **HTTP Request for Token Verification**:
    *   Add an **HTTP Request** node immediately after the Webhook Trigger.
    *   Set the `API Key` header to the **Service Role Secret** (private API key) <a class="yt-timestamp" data-t="00:14:49">[00:14:49]</a>.
    *   Set the `Authorization` header to `json.headers.authorization` <a class="yt-timestamp" data-t="00:15:07">[00:15:07]</a>. This extracts the Supabase token passed from the front end.
    *   The URL for this GET request should be `your_project_URL/auth/v1/user` <a class="yt-timestamp" data-t="00:15:27">[00:15:27]</a>. This endpoint verifies the user's bearer token and returns a valid user object if successful <a class="yt-timestamp" data-t="00:15:32">[00:15:32]</a>.
4.  **Conditional Logic**: Use an `If` statement node to check for the presence of an `email` attribute in the returned user object <a class="yt-timestamp" data-t="00:15:47">[00:15:47]</a>. If an email exists, authentication is successful, and the workflow continues; otherwise, an error can be returned <a class="yt-timestamp" data-t="00:16:01">[00:16:01]</a>.

While pasting the Supabase API key directly into the workflow parameter works, for enhanced security, consider using a secret management service like AWS Secrets Manager to store and fetch the key <a class="yt-timestamp" data-t="00:16:27">[00:16:27]</a>.

### Final Deployment and Testing
After updating the Streamlit Python code with the Supabase URL, Anonymous authentication key, and n8n webhook URL, the application can be re-run <a class="yt-timestamp" data-t="00:17:35">[00:17:35]</a>.

Although Claude may occasionally hallucinate (e.g., suggesting deprecated features), it is generally effective at correcting itself through an iterative prompting process <a class="yt-timestamp" data-t="00:19:13">[00:19:13]</a>. The updated application will present a login/signup interface. Upon successful login, the user's email and session ID will be displayed, and the AI agent can be interacted with, with all Supabase authentication and verification handled seamlessly in the backend <a class="yt-timestamp" data-t="00:19:47">[00:19:47]</a>.

This robust setup provides a strong foundation for [[deploying and monitoring_ai_agents | deploying and monitoring AI agents]] with secure, custom front ends, enabling businesses to leverage AI applications effectively in production environments. Further expansion can include additional security measures or UI enhancements.