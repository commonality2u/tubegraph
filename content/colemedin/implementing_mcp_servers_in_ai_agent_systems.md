---
title: Implementing MCP servers in AI agent systems
videoId: -Fpp4CBo14g
---

From: [[colemedin]] <br/> 

The integration of **[[integrating_mcp_with_ai_agents | MCP servers]]** into AI agent systems allows for the creation of sophisticated, highly specialized AI agents capable of connecting to diverse services and managing complex tasks without being overwhelmed <a class="yt-timestamp" data-t="00:00:52">[00:00:52]</a>. This approach marks the beginning of the ultimate personal assistant <a class="yt-timestamp" data-t="00:01:01">[00:01:01]</a>.

## Archon: The AI Agent Builder

Archon is an open-source AI agent designed to build other AI agents <a class="yt-timestamp" data-t="00:00:02">[00:00:02]</a>. It's considered the world's first "agenteer" <a class="yt-timestamp" data-t="00:00:10">[00:00:10]</a>, capable of building AI agents with pure code, thereby avoiding platform lock-in <a class="yt-timestamp" data-t="00:00:15">[00:00:15]</a>. Archon utilizes advanced agentic techniques to build agents on the fly, yielding superior results compared to generalist AI coding assistants <a class="yt-timestamp" data-t="00:00:21">[00:00:21]</a>.

Archon is being developed as a free and open-source tool, following a "build in public" approach with iterative development <a class="yt-timestamp" data-t="00:01:41">[00:01:41]</a>. It also serves as an educational framework, teaching advanced agentic concepts using Python AI frameworks like [[building_ai_agents_with_pantic_ai_and_mcp | Pyantic AI]] and Langraph <a class="yt-timestamp" data-t="00:02:03">[00:02:03]</a>.

## The AI Agent Army: A Case Study in MCP Integration

Using Archon, an "AI agent army" was created, consisting of specialized sub-agents, each leveraging an **[[integrating_mcp_with_ai_agents | MCP server]]** <a class="yt-timestamp" data-t="00:00:47">[00:00:47]</a>. This setup allows a primary agent to connect to various services easily <a class="yt-timestamp" data-t="00:00:55">[00:00:55]</a>. The code for this system was generated by Archon itself, requiring only a few iterations for refinement <a class="yt-timestamp" data-t="00:03:15">[00:03:15]</a>.

### Benefits of Specialized Agents with MCP

The primary reason for setting up specialized agents with [[integrating_mcp_with_ai_agents | MCP tools]] is to mitigate the risk of LLMs becoming overwhelmed <a class="yt-timestamp" data-t="00:03:51">[00:03:51]</a>. Each tool increases the prompt length to the LLM <a class="yt-timestamp" data-t="00:04:08">[00:04:08]</a>. By distributing the burden of different tools among specialized agents, prompts remain smaller, reducing the chance of LLM overwhelm <a class="yt-timestamp" data-t="00:04:14">[00:04:14]</a>. The primary agent only needs to dispatch requests to the appropriate sub-agent based on the required **[[integrating_mcp_with_ai_agents | MCP server]]** <a class="yt-timestamp" data-t="00:04:24">[00:04:24]</a>. Instead of choosing from 30 different tools, the primary agent only selects from six different sub-agents <a class="yt-timestamp" data-t="00:12:41">[00:12:41]</a>.

### Demonstration of the AI Agent Army

The AI agent army can be deployed as an API endpoint, connecting to a front-end application for full chat and conversation history <a class="yt-timestamp" data-t="00:04:51">[00:04:51]</a>. Examples of its capabilities include:

*   **GitHub Integration**: Listing GitHub repositories by calling a dedicated GitHub sub-agent that uses tools from the GitHub **[[integrating_mcp_with_ai_agents | MCP server]]** <a class="yt-timestamp" data-t="00:05:15">[00:05:15]</a>.
*   **Web Search and Data Entry (Brave & AirTable)**: Searching the web for "top AI agent frameworks" using the Brave sub-agent <a class="yt-timestamp" data-t="00:06:09">[00:06:09]</a>, then adding the results to a frameworks table in AirTable via the AirTable sub-agent <a class="yt-timestamp" data-t="00:06:16">[00:06:16]</a>.
*   **Slack Integration**: Retrieving an AirTable base URL and sending it to a Slack channel using the AirTable and Slack sub-agents in tandem <a class="yt-timestamp" data-t="00:07:31">[00:07:31]</a>.

This demonstrates the system's ability to use multiple specialized agents for complex, multi-step requests, mimicking the actions of a personal assistant <a class="yt-timestamp" data-t="00:06:04">[00:06:04]</a>.

## Technical Setup: [[building_ai_agents_with_pantic_ai_and_mcp | Pantic AI]] and MCP Integration

The system leverages the new **[[integrating_mcp_with_ai_agents | MCP integration]]** released by [[building_ai_agents_with_pantic_ai_and_mcp | Pyantic AI]], a popular AI agent framework <a class="yt-timestamp" data-t="00:10:37">[00:10:37]</a>. Archon ingested the Pyantic AI documentation to understand how to build this integration <a class="yt-timestamp" data-t="00:10:51">[00:10:51]</a>.

The setup involves:
*   **Configuring Servers**: Defining **[[integrating_mcp_with_ai_agents | MCP servers]]** for services like Brave, AirTable, file system access, GitHub, Slack, and Firecrawl <a class="yt-timestamp" data-t="00:11:15">[00:11:15]</a>.
*   **Creating Sub-Agents**: Each sub-agent is designed to use a single **[[integrating_mcp_with_ai_agents | MCP server]]**, making it specialized <a class="yt-timestamp" data-t="00:11:50">[00:11:50]</a>. Even a less powerful LLM like GPT4 mini can perform well in this setup <a class="yt-timestamp" data-t="00:11:32">[00:11:32]</a>.
*   **Primary Agent**: The primary agent is equipped with tools to call each of the sub-agents <a class="yt-timestamp" data-t="00:12:03">[00:12:03]</a>. Its "doc string" helps it understand when and how to use each sub-agent <a class="yt-timestamp" data-t="00:12:09">[00:12:09]</a>.

This design offloads the burden of specific tool selection from the primary agent, allowing it to focus solely on which sub-agent to invoke <a class="yt-timestamp" data-t="00:12:29">[00:12:29]</a>.

## Extending the MCP Agent Army

This system serves as a template for building personal assistants, allowing users to connect any **[[integrating_mcp_with_ai_agents | MCP server]]** to their custom AI agents <a class="yt-timestamp" data-t="00:10:17">[00:10:17]</a>. The specialized agent setup enables the addition of many **[[integrating_mcp_with_ai_agents | MCP servers]]** (e.g., 10, 12, 15, 20) without overwhelming the system <a class="yt-timestamp" data-t="00:10:27">[00:10:27]</a>.

To extend the system:
1.  Define the **[[integrating_mcp_with_ai_agents | MCP server]]** configuration.
2.  Define a sub-agent for that server.
3.  Define a tool for the primary agent to use that sub-agent <a class="yt-timestamp" data-t="00:13:09">[00:13:09]</a>.

Archon can assist in this process, using existing code as a starting point to add new **[[integrating_mcp_with_ai_agents | MCP servers]]** <a class="yt-timestamp" data-t="00:13:21">[00:13:21]</a>.

## Future Developments for Archon

Archon continues to evolve with significant updates planned:

*   **Version 6 (Tool Library & MCP Integration)**: This version introduced a tool library and [[integrating_mcp_with_ai_agents | MCP integration]] <a class="yt-timestamp" data-t="00:15:52">[00:15:52]</a>. It includes pre-built tools, examples, and **[[integrating_mcp_with_ai_agents | MCP server]]** configurations <a class="yt-timestamp" data-t="00:16:00">[00:16:00]</a>. A new "advisor" agent intelligently selects examples, pre-built tools, and **[[integrating_mcp_with_ai_agents | MCP servers]]** based on user requests, feeding them to the primary coder agent <a class="yt-timestamp" data-t="00:17:16">[00:17:16]</a>.
*   **Langraph Documentation Integration**: Future plans include incorporating Langraph documentation alongside [[building_ai_agents_with_pantic_ai_and_mcp | Pyantic AI]] to enable Archon to build even more sophisticated AI agents <a class="yt-timestamp" data-t="00:17:54">[00:17:54]</a>.
*   **Version 9 (Autonomous Refinement)**: This ambitious update will allow Archon to not only build agents but also spin up isolated environments, create databases, run the agents, check for errors, and autonomously refine them based on performance <a class="yt-timestamp" data-t="00:18:20">[00:18:20]</a>. This will take the self-feedback loop to the next level <a class="yt-timestamp" data-t="00:18:36">[00:18:36]</a>.