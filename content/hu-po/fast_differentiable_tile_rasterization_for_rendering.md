---
title: Fast differentiable tile rasterization for rendering
videoId: xgwvU7S0K-k
---

From: [[hu-po]] <br/> 

Fast differentiable tile rasterization is a key component of the [[3d_gaussian_splatting_for_realtime_radiance_field_rendering | 3D Gaussian Splatting]] method, enabling state-of-the-art visual quality and real-time novel view synthesis while maintaining competitive training times <a class="yt-timestamp" data-t="00:10:02">[00:10:02]</a>.

## Purpose and Advantages
This rendering algorithm supports [[Goshan Splat optimization for 3D reconstruction | anisotropic splatting]], accelerates training, and allows real-time rendering <a class="yt-timestamp" data-t="00:08:28">[00:08:28]</a>. Unlike traditional [[Ray marching and differentiable rendering | Ray marching]] methods used in Neural Radiance Fields (NeRFs) which are costly to train and render <a class="yt-timestamp" data-t="00:04:16">[00:04:16]</a> and cannot achieve real-time display rates at 1080p resolution <a class="yt-timestamp" data-t="00:05:50">[00:05:50]</a>, this approach ensures real-time rendering and high quality <a class="yt-timestamp" data-t="01:17:15">[01:17:15]</a>.

The fast rasterizer is critical to the efficiency of the overall optimization process, as it is the main computational bottleneck <a class="yt-timestamp" data-t="01:23:56">[01:23:56]</a>. It is also fully [[Differentiable rendering and optimization | differentiable]], allowing gradients to be passed backwards through the rendering pipeline for scene optimization <a class="yt-timestamp" data-t="01:00:26">[01:00:26]</a> <a class="yt-timestamp" data-t="01:40:46">[01:40:46]</a>.

## How it Works
The fast differentiable rasterizer works by:
1.  **Tile-Based Screen Division** The screen is split into 16x16 pixel tiles <a class="yt-timestamp" data-t="01:40:04">[01:40:04]</a>. This tile size is also common in video compression standards like MP4 and H.264 <a class="yt-timestamp" data-t="01:44:35">[01:44:35]</a>.
2.  **Gaussian Culling** 3D Gaussians are culled against the view frustum, keeping only those with a 99% confidence interval intersecting it <a class="yt-timestamp" data-t="01:42:12">[01:42:12]</a>. A "guard band" is initially used to trivially reject Gaussians at extreme positions <a class="yt-timestamp" data-t="01:42:20">[01:42:20]</a>.
3.  **Key Assignment and Sorting** Each Gaussian instance is initialized according to the number of tiles it overlaps and assigned a key that combines its view space depth and tile ID <a class="yt-timestamp" data-t="01:43:01">[01:43:01]</a>. These keys, up to 64 bits (32 for depth, 32 for tile index) <a class="yt-timestamp" data-t="01:48:43">[01:48:43]</a>, allow Gaussians to be sorted efficiently <a class="yt-timestamp" data-t="01:41:30">[01:41:30]</a>.
4.  **GPU Radix Sort** A single fast [[Scalable diffusion models with Transformers | GPU Radix sort]] is used to sort the Gaussians based on these keys <a class="yt-timestamp" data-t="01:43:23">[01:43:23]</a>. This parallel sorting algorithm breaks down the sorting problem into manageable steps, leveraging the GPU's processing power <a class="yt-timestamp" data-t="01:44:57">[01:44:57]</a>. The use of an optimized GPU Radix sort is a key enabler for speed <a class="yt-timestamp" data-t="01:48:33">[01:48:33]</a>.
5.  **Tile Processing and Alpha Blending** For each tile, a list of Gaussians is produced <a class="yt-timestamp" data-t="01:45:50">[01:45:50]</a>. One thread block is launched for each tile, which collaboratively loads Gaussian packets into shared memory <a class="yt-timestamp" data-t="01:46:09">[01:46:09]</a>. For each pixel, colors and alpha values are accumulated through alpha blending <a class="yt-timestamp" data-t="01:46:12">[01:46:12]</a>.
6.  **Saturation Stopping Criterion** The blending process stops when a target saturation is reached for a pixel, meaning the corresponding thread stops <a class="yt-timestamp" data-t="01:46:50">[01:46:50]</a>. This is similar to NeRFs, where sampling along a ray stops once a certain level of opacity is achieved <a class="yt-timestamp" data-t="01:47:10">[01:47:10]</a>.
7.  **Backward Pass Optimization** To allow for an arbitrary number of blended Gaussians to receive gradient updates without hard limits <a class="yt-timestamp" data-t="01:39:39">[01:39:39]</a>, the system avoids storing excessively long lists of blended points in global memory <a class="yt-timestamp" data-t="01:53:11">[01:53:11]</a>. Instead, it reuses the sorted arrays and tile ranges from the forward pass and traverses them back-to-front <a class="yt-timestamp" data-t="01:54:15">[01:54:15]</a>. Intermediate opacities required for gradient computation are recovered by storing only the total accumulated opacity at the end of the forward pass <a class="yt-timestamp" data-t="01:54:53">[01:54:53]</a>.

## Inspirations and Related Work
The tile-based rasterizer is inspired by recent software rasterization approaches like Pulsar (2021) and Adopt, which pre-sort primitives for an entire image at once <a class="yt-timestamp" data-t="01:39:58">[01:39:58]</a> <a class="yt-timestamp" data-t="01:50:20">[01:50:20]</a>. These previous methods motivated the development of this fast rendering solution <a class="yt-timestamp" data-t="00:53:02">[00:53:02]</a>. The use of custom Cuda kernels also plays a role in its speed <a class="yt-timestamp" data-t="01:23:44">[01:23:44]</a>.

## Limitations and Future Work
Despite its advantages, the rasterizer is not without limitations. Popping artifacts can occasionally occur when the optimization creates large Gaussians, particularly in regions with view-dependent appearance <a class="yt-timestamp" data-t="02:21:18">[02:21:18]</a>. This can be partly attributed to the trivial rejection of Gaussians via the guard band and simple visibility models <a class="yt-timestamp" data-t="02:21:47">[02:21:47]</a>. Anti-aliasing is suggested as future work to address this <a class="yt-timestamp" data-t="02:22:14">[02:22:14]</a>.