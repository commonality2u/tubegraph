---
title: Performance and efficiency in machine learning models
videoId: rzXjKcqkjxM
---

From: [[hu-po]] <br/> 

The development of machine learning models continually seeks to balance performance with computational efficiency, particularly when dealing with long sequences of data <a class="yt-timestamp" data-t="00:10:15">[00:10:15]</a>.

## Mamba vs. Transformer Architectures

Traditional machine learning architectures, such as Convolutional Neural Networks (CNNs) and Transformers, have limitations when processing long sequences of data <a class="yt-timestamp" data-t="00:07:39">[00:07:39]</a> <a class="yt-timestamp" data-t="00:14:30">[00:14:30]</a>. Transformers, despite their power, face a significant challenge due to their `[[Energy and Compute Optimization in AI Models | attention mechanisms]]` <a class="yt-timestamp" data-t="00:14:43">[00:14:43]</a>. The computational requirements of Transformers increase substantially because the attention map scales quadratically with the length of the input sequence <a class="yt-timestamp" data-t="00:14:50">[00:14:50]</a>. This quadratic scaling makes Transformers very memory and compute intensive <a class="yt-timestamp" data-t="00:11:15">[00:11:15]</a>.

In contrast, Mamba models, a type of state space model (SSM), offer a more efficient alternative <a class="yt-timestamp" data-t="00:08:03">[00:08:03]</a>. Mamba models have a linear complexity operator, leading to faster speeds and lower GPU consumption compared to Transformers <a class="yt-timestamp" data-t="00:16:03">[00:16:03]</a> <a class="yt-timestamp" data-t="00:10:50">[00:10:50]</a>. This efficiency stems from their approach of maintaining a hidden state that propagates forward in time, with a capped length <a class="yt-timestamp" data-t="00:11:00">[00:11:00]</a> <a class="yt-timestamp" data-t="00:15:19">[00:15:19]</a>. This means their memory and compute requirements scale linearly with the sequence length <a class="yt-timestamp" data-t="00:15:27">[00:15:27]</a>.

The fundamental difference lies in how they handle information:
*   **State Space Models (Mamba):** Maintain a compressed hidden state, sequentially updating it. Information from earlier in the sequence might be "forgotten" as new information is processed <a class="yt-timestamp" data-t="00:27:07">[00:27:07]</a> <a class="yt-timestamp" data-t="01:53:50">[01:53:50]</a>. While faster for long sequences, this sequential processing means they might have an inductive bias that things further back in time are less important <a class="yt-timestamp" data-t="01:54:26">[01:54:26]</a>.
*   **Transformers:** Save all past representations and attend to them <a class="yt-timestamp" data-t="00:27:25">[00:27:25]</a>. This allows them to compute all possible interactions in parallel <a class="yt-timestamp" data-t="00:28:15">[00:28:15]</a>. They generally have less inductive bias and can potentially yield more powerful representations <a class="yt-timestamp" data-t="01:54:01">[01:54:01]</a>.

The success of Mamba models often depends on the rate of GPU performance improvement <a class="yt-timestamp" data-t="01:31:31">[01:31:31]</a>. If GPUs continue to improve drastically, the quadratic scaling of Transformers might become less of a concern. However, if GPU advancements slow, Mamba models could become increasingly vital for handling large and complex data, such as 4K video at 120 frames per second or detailed 3D motion models with many joints <a class="yt-timestamp" data-t="01:31:48">[01:31:48]</a> <a class="yt-timestamp" data-t="01:32:48">[01:32:48]</a>.

## State Space Models (SSMs) and their Evolution

State space models are conceptualized as continuous systems that map a 1D function or sequence through a hidden state (H) <a class="yt-timestamp" data-t="00:29:36">[00:29:36]</a>. This continuous ordinary differential equation (ODE) is discretized for practical use, typically using a zero-order hold method to approximate continuous functions with piecewise constant signals <a class="yt-timestamp" data-t="00:31:48">[00:31:48]</a>.

Older SSMs, like Recurrent Neural Networks (RNNs) and Long Short-Term Memory networks (LSTMs), faced challenges with `[[parallelism_and_scalability_in_machine_learning | parallel training]]` because calculating the next hidden state depended on the previous one <a class="yt-timestamp" data-t="00:26:05">[00:26:05]</a> <a class="yt-timestamp" data-t="00:37:07">[00:37:07]</a>. Modern Mamba models, however, incorporate techniques that allow them to be trained in parallel, similar to convolutional networks, making them more efficient for current hardware <a class="yt-timestamp" data-t="00:16:23">[00:16:23]</a>.

Different "scanning" strategies are employed in Mamba models to process sequences:
*   **Spatial-first bidirectional scan:** Processes an entire frame (spatial dimension) before moving to the next frame (temporal dimension) <a class="yt-timestamp" data-t="00:51:54">[00:51:54]</a>. This strategy is found to be effective and simple for video understanding tasks <a class="yt-timestamp" data-t="00:59:03">[00:59:03]</a>.
*   **Temporal-first bidirectional scan:** Processes a specific patch or location across all frames before moving to the next patch <a class="yt-timestamp" data-t="00:52:10">[00:52:10]</a>.
*   **Hierarchical scanning:** Used in motion generation models, this strategy adjusts the number of scans depending on the level of the encoder-decoder hierarchy <a class="yt-timestamp" data-t="00:55:56">[00:55:56]</a>. Lower levels, dealing with high-frequency, detailed features (e.g., specific joint movements), require more scans, while higher levels, dealing with abstract, semantic features (e.g., "walking"), require fewer <a class="yt-timestamp" data-t="00:57:02">[00:57:02]</a> <a class="yt-timestamp" data-t="00:58:16">[00:58:16]</a>. This method enhances temporal alignment and reduces computational overhead <a class="yt-timestamp" data-t="00:58:28">[00:58:28]</a>.

## [[Optimization Methods in Machine Learning | Optimization Strategies for Efficiency]]

Several `[[Optimization Methods in Machine Learning | optimization methods]]` are explored to enhance model performance and reduce overfitting, especially with smaller datasets:

*   **Masked Training:** This involves randomly masking out parts of the input data (e.g., video frames) during training <a class="yt-timestamp" data-t="01:05:33">[01:05:33]</a>. This acts as a form of `[[Challenges and strategies in model training and performance | self-supervised learning]]` or regularization, forcing the model to pay attention to all parts of the input to make correct predictions <a class="yt-timestamp" data-t="01:06:03">[01:06:03]</a>. Examples include random masking, tube masking (masking the same spatial region across all frames), clip row masking, and frame row masking <a class="yt-timestamp" data-t="01:07:55">[01:07:55]</a>.
*   **Self-Distillation:** An unusual `[[finetuning machine learning models | distillation]]` technique where a smaller, well-trained teacher model guides the training of a larger student model <a class="yt-timestamp" data-t="01:13:09">[01:13:09]</a>. This is counter-intuitive to typical distillation, which uses a larger teacher to compress into a smaller student <a class="yt-timestamp" data-t="01:13:21">[01:13:21]</a>. The rationale for this approach is to prevent the larger model from overfitting on a small dataset by leveraging the generalized features learned by the smaller model <a class="yt-timestamp" data-t="01:35:51">[01:35:51]</a>. This `[[finetuning machine learning models | distillation]]` can be combined with other losses, such as masking and classification, to improve convergence <a class="yt-timestamp" data-t="01:15:30">[01:15:30]</a>.
*   **Latent Diffusion Models:** For generative tasks like motion generation, models use a variational autoencoder (VAE) to compress high-dimensional motion data into a lower-dimensional latent space <a class="yt-timestamp" data-t="01:06:05">[01:06:05]</a>. The diffusion process (iteratively removing noise) then occurs in this more efficient latent space <a class="yt-timestamp" data-t="01:06:27">[01:06:27]</a>. Text encoders (e.g., a frozen CLIP text encoder) are used to condition the denoiser, allowing text-to-motion generation <a class="yt-timestamp" data-t="01:07:55">[01:07:55]</a>.

## Challenges in Evaluation and Benchmarking

Evaluating model performance, especially in new domains or with complex modalities like video and motion, presents `[[Challenges and strategies in model training and performance | challenges]]`:
*   **Quantitative Metrics:** Metrics like Fr√©chet Inception Distance (FID) are commonly used for generative models, but their reliability can be debated <a class="yt-timestamp" data-t="01:17:19">[01:17:19]</a>. High scores on benchmarks don't always reflect generalizability, as models can overfit to specific datasets by incorporating inductive biases <a class="yt-timestamp" data-t="01:48:54">[01:48:54]</a>.
*   **Dataset Size:** Datasets for motion generation (e.g., HumanML3D, KIT ML) are relatively small (thousands of motions), which can lead to overfitting in larger models <a class="yt-timestamp" data-t="01:20:28">[01:20:28]</a>. This may necessitate techniques like self-distillation to achieve better results <a class="yt-timestamp" data-t="01:35:51">[01:35:51]</a>. Future improvements might involve using trained generative models to synthesize larger datasets <a class="yt-timestamp" data-t="01:21:24">[01:21:24]</a>.
*   **Benchmark Relevance:** For Mamba models, whose strength lies in `[[efficiency of large language models | efficiency with long sequences]]`, benchmarks based on short videos or low-resolution images may not fully showcase their advantage over Transformers <a class="yt-timestamp" data-t="01:44:50">[01:44:50]</a>. Instead, evaluation on very long, high-resolution sequences would better highlight their superior inference speed <a class="yt-timestamp" data-t="01:45:00">[01:45:00]</a>.