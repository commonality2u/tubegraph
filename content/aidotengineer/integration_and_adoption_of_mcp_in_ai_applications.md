---
title: Integration and adoption of mCP in AI applications
videoId: kQmXtrmQ5Zg
---

From: [[aidotengineer]] <br/> 

The Model Context Protocol (mCP) is an open protocol developed by Anthropic's applied AI team to enable seamless integration between AI applications and agents with various tools and data sources <a class="yt-timestamp" data-t="01:58:00">[01:58:00]</a>. It addresses the core concept that models are only as effective as the context provided to them <a class="yt-timestamp" data-t="01:19:00">[01:19:00]</a>.

## Motivation Behind mCP
Historically, AI applications and chatbots required users to manually copy-paste or type context <a class="yt-timestamp" data-t="01:33:00">[01:33:00]</a>. Over time, these systems evolved to include "hooks" into user data and context, making them more powerful and personalized <a class="yt-timestamp" data-t="01:46:00">[01:46:00]</a>. Anthropic identified an opportunity to create mCP to standardize this integration <a class="yt-timestamp" data-t="01:55:00">[01:55:00]</a>.

mCP is inspired by preceding protocols:
*   **APIs** standardized how web applications interact between front-end and back-end, allowing front-ends access to servers and databases <a class="yt-timestamp" data-t="02:12:00">[02:12:00]</a>.
*   **Language Server Protocol (LSP)** standardized how IDEs interact with language-specific tools, allowing any LSP-compatible IDE to hook into various coding language features <a class="yt-timestamp" data-t="02:37:00">[02:37:00]</a>.

Similar to these, mCP standardizes how AI applications interact with external systems <a class="yt-timestamp" data-t="03:10:00">[03:10:00]</a>.

## Addressing Industry Fragmentation
Before mCP, Anthropic observed significant fragmentation in how AI systems were built, both across the industry and within individual companies <a class="yt-timestamp" data-t="03:41:00">[03:41:00]</a>. Teams would create custom implementations for integrating AI apps with context, leading to varied prompt logic and inconsistent ways of bringing in tools and data <a class="yt-timestamp" data-t="03:53:00">[03:53:00]</a>.

The world with mCP aims for standardized AI development <a class="yt-timestamp" data-t="04:15:00">[04:15:00]</a>. An mCP client (e.g., Anthropic's first-party applications, Cursor, Windsurf, Goose) can connect to any mCP server with zero additional work <a class="yt-timestamp" data-t="04:26:00">[04:26:00]</a>. An mCP server acts as a wrapper to federate access to various relevant systems and tools, such as databases, CRM systems like Salesforce, or local systems like Git <a class="yt-timestamp" data-t="04:52:00">[04:52:00]</a>.

## Value Proposition of mCP
The adoption of mCP has shown value across the ecosystem <a class="yt-timestamp" data-t="05:33:00">[05:33:00]</a>:

*   **Application Developers**: Once an application is mCP compatible, it can connect to any server without extra work <a class="yt-timestamp" data-t="05:42:00">[05:42:00]</a>.
*   **Tool/API Providers**: They can build an mCP server once and see it adopted across various AI applications <a class="yt-timestamp" data-t="05:51:00">[05:51:00]</a>. This flattens the "N times M problem" of numerous permutations for client-server interactions <a class="yt-timestamp" data-t="06:06:00">[06:06:00]</a>.
*   **End Users**: mCP leads to more powerful and context-rich AI applications, enabling systems that are context-aware and can take actions in the real world <a class="yt-timestamp" data-t="06:28:00">[06:28:00]</a>.
*   **Enterprises**: mCP provides a clear way to separate concerns between teams. For instance, a team owning infrastructure can build and maintain an mCP server for a vector database or RAG system, allowing other teams to build AI applications faster without needing direct access or custom implementations every time <a class="yt-timestamp" data-t="06:48:00">[06:48:00]</a>. This is analogous to the benefits of microservices architectures <a class="yt-timestamp" data-t="07:49:00">[07:49:00]</a>.

## Core Components of the Protocol
mCP standardizes interaction through three primary interfaces <a class="yt-timestamp" data-t="03:17:00">[03:17:00]</a>:

1.  **Tools**: These are "model-controlled," meaning the LLM within the client application chooses when to invoke them <a class="yt-timestamp" data-t="10:27:00">[10:27:00]</a>. Servers expose tools with descriptions, and the model decides the best time to use them <a class="yt-timestamp" data-t="10:48:00">[10:48:00]</a>. Tools can be used for reading/retrieving data, writing/sending data to applications, updating databases, or writing files <a class="yt-timestamp" data-t="11:04:00">[11:04:00]</a>.
2.  **Resources**: These are "application-controlled" data exposed to the application <a class="yt-timestamp" data-t="11:23:00">[11:23:00]</a>. Servers can define static or dynamic resources (e.g., images, text files, JSON) which the client application then uses as it sees fit <a class="yt-timestamp" data-t="11:31:00">[11:31:00]</a>. Resources provide a rich interface beyond simple text-based chat interactions <a class="yt-timestamp" data-t="11:50:00">[11:50:00]</a>. In Claude for desktop, resources manifest as attachments that users can select to send to the model, or the model can automatically attach them <a class="yt-timestamp" data-t="12:24:00">[12:24:24]</a>. Resources can also be dynamic, interpolated with context from the user or application <a class="yt-timestamp" data-t="20:50:00">[20:50:00]</a>. Resource notifications allow clients to subscribe to a resource and be notified when it's updated by the server <a class="yt-timestamp" data-t="21:17:00">[21:17:00]</a>.
3.  **Prompts**: These are "user-controlled" and act as predefined templates for common interactions with a specific server <a class="yt-timestamp" data-t="12:56:00">[12:56:00]</a>. An example is a slash command in an IDE like Zed that expands into a longer, predefined prompt, which is then sent to the LLM <a class="yt-timestamp" data-t="13:14:00">[13:14:00]</a>. Prompts allow teams to standardize interactions like document Q&A or data formatting rules <a class="yt-timestamp" data-t="13:49:00">[13:49:00]</a>. Prompts can also be dynamic and customized based on the task at hand <a class="yt-timestamp" data-t="21:08:00">[21:08:00]</a>.

> "The point of mCP is to give more control to each of these different parts of the system as opposed to only just the model itself." <a class="yt-timestamp" data-t="22:30:00">[22:30:00]</a>

## [[integration_of_ai_into_development_environments_and_editors | Integration of AI into Development Environments and Editors]] and Applications
mCP has seen significant adoption in applications and IDEs, providing a way for users to provide context while coding <a class="yt-timestamp" data-t="08:21:00">[08:21:00]</a>. The agents within these IDEs can then interact with external systems like GitHub or documentation sites <a class="yt-timestamp" data-t="08:34:00">[08:34:00]</a>.

As of the time of the talk, there were over 1,100 community-built servers published open-source, in addition to servers built by companies and official integrations <a class="yt-timestamp" data-t="08:44:00">[08:44:00]</a>.

An example of [[integrating_ai_into_natural_workflows | integrating AI into natural workflows]] with mCP is using Claude for desktop (an mCP client) with a GitHub server <a class="yt-timestamp" data-t="22:52:00">[22:52:00]</a>. The user can provide a GitHub repository URL and ask Claude to pull and triage issues <a class="yt-timestamp" data-t="23:13:00">[23:13:00]</a>. Claude, using the `list issues` tool from a community-built GitHub server, can summarize and intelligently prioritize issues based on user context <a class="yt-timestamp" data-t="23:29:00">[23:29:00]</a>. It can also autonomously find and add tasks to an Asana project using an Asana server with multiple tools <a class="yt-timestamp" data-t="24:15:00">[24:15:00]</a>. These servers are often just a couple hundred lines of code, primarily surfacing tools <a class="yt-timestamp" data-t="24:58:00">[24:58:00]</a>. This makes Claude for desktop a central dashboard for managing daily tasks and integrating context from various systems <a class="yt-timestamp" data-t="25:23:00">[25:23:00]</a>.

Other applications like Windsurf and Goose also demonstrate mCP integration, showing how application builders can decide how to bring mCP context into their unique UIs and agent experiences <a class="yt-timestamp" data-t="25:52:00">[25:52:00]</a>.

## mCP as a Foundational Protocol for Agents
mCP is anticipated to become a foundational protocol for agents broadly, driven by its protocol features and the increasing effectiveness of agent systems and models <a class="yt-timestamp" data-t="26:36:00">[26:36:00]</a>.

Agents are often conceptualized as an "augmented LLM" running in a loop <a class="yt-timestamp" data-t="28:54:00">[28:54:00]</a>. This augmented LLM takes inputs, produces outputs, and uses its intelligence, but is augmented by retrieval systems, tools, and memory <a class="yt-timestamp" data-t="27:29:00">[27:29:00]</a>. mCP fits in as the entire bottom layer, making it easier for LLMs to talk to retrieval systems, invoke tools, and incorporate memory in a standardized way <a class="yt-timestamp" data-t="28:10:00">[28:10:00]</a>. This means agents can expand their capabilities even after initialization, discovering new interactions without needing to be pre-programmed <a class="yt-timestamp" data-t="28:34:00">[28:34:00]</a>.

Agent systems, at their core, involve an augmented LLM running in a loop: performing a task, working towards a goal, invoking a tool, analyzing the response, and repeating until the task is complete <a class="yt-timestamp" data-t="28:57:00">[28:57:00]</a>. mCP provides these capabilities in an open way, allowing agent builders to focus on the core loop (context management, memory usage, model choice) while users can customize the agent's interaction with their data <a class="yt-timestamp" data-t="29:47:00">[29:47:00]</a>.

An example using the open-source mCP Agent framework by Last Mile AI demonstrates this <a class="yt-timestamp" data-t="30:19:00">[30:19:00]</a>. An agent can be defined with a task (e.g., research Quantum Computing's impact on cybersecurity) and given access to mCP servers for web searching (Brave), fetching data (Fetch), and file system access <a class="yt-timestamp" data-t="30:52:00">[30:52:00]</a>. The framework allows defining sub-agents (e.g., a "research agent" and a "fact checker agent") that leverage these mCP servers <a class="yt-timestamp" data-t="31:17:00">[31:17:00]</a>. The agent forms a plan (series of steps) based on its task and available servers, enabling it to autonomously perform research, verification, and report generation <a class="yt-timestamp" data-t="33:00:00">[33:00:00]</a>. This allows agent builders to focus on the task and agent interactions rather than the intricacies of the servers themselves <a class="yt-timestamp" data-t="33:48:00">[33:48:00]</a>.

### Key Protocol Capabilities for Agents
*   **Sampling**: Allows an mCP server to request LLM inference calls from the client, meaning the server doesn't need to implement or host its own LLM interactions <a class="yt-timestamp" data-t="53:52:00">[53:52:00]</a>. The client owns all LLM interactions, including model preferences, privacy controls, and cost parameters <a class="yt-timestamp" data-t="54:55:00">[54:55:00]</a>. This is crucial when clients interact with servers they have never seen before, as it provides a standardized way for the server to request intelligence <a class="yt-timestamp" data-t="55:56:00">[55:56:00]</a>.
*   **Composability**: An application, API, or agent can act as both an mCP client and an mCP server <a class="yt-timestamp" data-t="56:21:00">[56:21:00]</a>. This allows for chaining interactions and building complex, multi-layered architectures where each layer or "agent" specializes in a particular task <a class="yt-timestamp" data-t="57:17:00">[57:17:00]</a>. For example, a user talks to Claude for desktop (client + LLM), which calls a research agent (server + client), which then calls various other servers (file system, web search) <a class="yt-timestamp" data-t="56:41:00">[56:41:00]</a>. This hierarchical system allows for flexible agent-to-agent communication where agents can have autonomy and make decisions on how to pull in richer data <a class="yt-timestamp" data-t="01:00:10">[01:00:10]</a>.

The combination of sampling and composability is particularly exciting for agents <a class="yt-timestamp" data-t="01:11:43">[01:11:43]</a>. An orchestrator agent can be an mCP server for the user's client and an mCP client to other specialized agents (e.g., analysis, coding, research agents), all while federating sampling requests back to the primary application controlling the LLM interaction <a class="yt-timestamp" data-t="01:11:50">[01:11:50]</a>. This enables hierarchical agent systems that can connect to agents living on the public web while maintaining privacy, security, and control <a class="yt-timestamp" data-t="01:12:35">[01:12:35]</a>.

## [[future_developments_and_roadmap_for_mcp | Future Developments and Roadmap for mCP]]
### Remote Servers and Authentication (Auth)
A significant development is support for remotely hosted mCP servers and OAuth 2.0 authentication <a class="yt-timestamp" data-t="01:12:28">[01:12:28]</a>. This allows servers to live on public URLs and be discoverable <a class="yt-timestamp" data-t="01:15:09">[01:15:09]</a>. The server orchestrates the OAuth handshake, getting a callback URL, which the client opens for user authentication. The server then holds the OAuth token and federates future interactions using a session token <a class="yt-timestamp" data-t="01:14:22">[01:14:22]</a>. This removes dev experience friction, making mCP servers as accessible as websites, and enables the agent and LLM to live on a completely different system from the server <a class="yt-timestamp" data-t="01:15:30">[01:15:30]</a>.

### mCP Registry and Discovery
A major ongoing effort is the creation of an official mCP registry API <a class="yt-timestamp" data-t="01:22:00">[01:22:00]</a>. This unified, hosted metadata service, built in the open, will address challenges with discovering and pulling in mCP servers, which are currently fragmented across various package systems (npm, pip) <a class="yt-timestamp" data-t="01:22:30">[01:22:30]</a>. The registry will help with:
*   **Discoverability**: Knowing the protocol for an mCP server (e.g., standard IO, SSE), its location (local file vs. URL) <a class="yt-timestamp" data-t="01:23:12">[01:23:12]</a>.
*   **Trust and Verification**: Identifying who built a server and if it's officially verified by a company (e.g., Shopify) <a class="yt-timestamp" data-t="01:23:25">[01:23:25]</a>.
*   **Versioning**: Providing a log of changes to server capabilities, tools, or tool descriptions <a class="yt-timestamp" data-t="01:24:01">[01:24:01]</a>.

The registry will enable agents to be "self-evolving" by dynamically discovering new capabilities and data on the fly <a class="yt-timestamp" data-t="01:35:59">[01:35:59]</a>. For example, a coding agent could search the registry for a verified Grafana server if it needs to check logs, install or invoke it remotely, and then proceed to fix a bug <a class="yt-timestamp" data-t="01:36:16">[01:36:16]</a>. This allows agents to choose their own tools, making augmented LLM systems even more powerful without predefined packages <a class="yt-timestamp" data-t="01:36:56">[01:36:56]</a>.

### Well-Known mCP
Complementing the registry is the concept of a `/.well-known/mcp.json` endpoint <a class="yt-timestamp" data-t="01:39:24">[01:39:24]</a>. This allows service providers (e.g., shopify.com) to provide a verified interface indicating an mCP endpoint exists, its capabilities (resources, tools), and authentication methods (OAuth 2.0) <a class="yt-timestamp" data-t="01:39:30">[01:39:30]</a>. An agent can then query this endpoint directly to manage a user's store <a class="yt-timestamp" data-t="01:39:48">[01:39:48]</a>. This provides a "top-down" approach to discovery and verification, working alongside the registry <a class="yt-timestamp" data-t="01:40:07">[01:40:07]</a>.

This also integrates well with Anthropic's "computer use" models, which can click around in UIs that lack APIs <a class="yt-timestamp" data-t="01:40:36">[01:40:36]</a>. The future envisions agents combining mCP's predefined API interaction with computer use for long-tail scenarios, creating a powerful blend of structured and unstructured interaction <a class="yt-timestamp" data-t="01:40:52">[01:40:52]</a>.

### Other Medium-Term Considerations
*   **Stateful vs. Stateless Connections**: Exploring short-lived connections for basic client-to-server requests versus long-lived SSE connections for advanced features like sampling and server-to-client notifications <a class="yt-timestamp" data-t="01:41:41">[01:41:41]</a>.
*   **Streaming**: Supporting first-class streaming of multiple data chunks from server to client over time <a class="yt-timestamp" data-t="01:42:41">[01:42:41]</a>.
*   **Namespace**: Addressing tool name conflicts when multiple servers are installed, potentially by allowing logical groups of tools <a class="yt-timestamp" data-t="01:42:51">[01:42:51]</a>.
*   **Proactive Server Behavior**: Developing patterns for servers to initiate actions (e.g., event-driven notifications, requesting more information from the user) rather than solely responding to client requests <a class="yt-timestamp" data-t="01:43:31">[01:43:31]</a>.

## Key Insights from Q&A
*   **Agent Frameworks**: mCP complements agent frameworks like LangChain, providing a standardized way to hook into servers, tools, prompts, and resources without replacing the framework's core logic (e.g., knowledge management, agentic loops) <a class="yt-timestamp" data-t="01:17:12">[01:17:12]</a>.
*   **Proprietary Data**: mCP servers can be run within a company's VPC or on individual employee systems, allowing [[using_existing_enterprise_systems_for_ai_integration | integration of AI into business operations]] with proprietary data <a class="yt-timestamp" data-t="01:35:43">[01:35:43]</a>.
*   **Tool Limits**: Current models can handle around 50-100 tools effectively <a class="yt-timestamp" data-t="01:46:40">[01:46:40]</a>. For thousands of tools, strategies like "tool to search tools" (RAG over tools, fuzzy/keyword search) or hierarchical tool systems can be used to manage context <a class="yt-timestamp" data-t="01:47:01">[01:47:01]</a>.
*   **Logic Placement**: Retrying logic and other business logic should ideally sit on the server side, as the server is closer to the end application and clients may not know server-specific interaction details <a class="yt-timestamp" data-t="01:44:57">[01:44:57]</a>.
*   **Debuggability**: While the protocol doesn't enforce specific observability, good servers should expose useful metadata for debugging to provide a good user experience <a class="yt-timestamp" data-t="01:55:00">[01:55:00]</a>. Tools like Anthropic's Inspector help examine server connections and interactions <a class="yt-timestamp" data-t="01:09:49">[01:09:49]</a>. LLMs can even auto-generate simpler servers <a class="yt-timestamp" data-t="01:49:21">[01:49:21]</a>.
*   **Governance and Security**: The server builder controls governance and security, including authorization and authentication, to manage client access to the end application <a class="yt-timestamp" data-t="01:10:56">[01:10:56]</a>. The trust of servers will become increasingly important with registries <a class="yt-timestamp" data-t="01:18:28">[01:18:28]</a>. Companies can self-host registries to control approved servers <a class="yt-timestamp" data-t="01:37:52">[01:37:52]</a>.
*   **Open Source Philosophy**: Anthropic intends mCP to remain open, even if it fosters competition among model providers, as it is ultimately beneficial for users and developers <a class="yt-timestamp" data-t="01:28:15">[01:28:15]</a>. Claude doesn't have a specific mCP advantage, but is generally good at tool use and agentic work <a class="yt-timestamp" data-t="01:29:14">[01:29:14]</a>.
*   **Transport Agnostic**: mCP is transport agnostic. Standard IO is typically used for local/in-memory communication, while SSE is for remote servers <a class="yt-timestamp" data-t="01:32:05">[01:32:05]</a>.
*   **Model in Loop**: The model does not always have to be in the loop to interact with the server; the client application can deterministically call server functions like `call tools` or `list resources` <a class="yt-timestamp" data-t="01:33:07">[01:33:07]</a>.