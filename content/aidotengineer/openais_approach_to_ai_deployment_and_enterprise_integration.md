---
title: OpenAIs approach to AI deployment and enterprise integration
videoId: joHR2pmxDQE
---

From: [[aidotengineer]] <br/> 

OpenAI focuses on helping [[building_and_scaling_ai_use_cases_for_enterprises | enterprises build and scale use cases]] and bring them to production <a class="yt-timestamp" data-t="00:00:24">[00:00:24]</a>. They also offer a sneak peek into [[agentic_enterprise_and_ai_agents | agents]] and experiences building agentic workflows <a class="yt-timestamp" data-t="00:00:29">[00:00:29]</a>.

## OpenAI's Operational Structure
OpenAI operates with two core engineering teams <a class="yt-timestamp" data-t="00:00:45">[00:00:45]</a>:
*   **Research Team:** Comprises 1,200 researchers who invent and deploy foundational models <a class="yt-timestamp" data-t="00:00:48">[00:00:48]</a>.
*   **Apply Team:** Takes these foundational models and builds them into products like ChatGPT and the API, making GPT models available for deployment <a class="yt-timestamp" data-t="00:01:00">[00:01:00]</a>.

Their go-to-market team helps get these products into the hands of a workforce and products to automate internal operations <a class="yt-timestamp" data-t="00:01:11">[00:01:11]</a>. This process involves an iterative loop, taking feedback from the field to improve products and core models through a research flywheel <a class="yt-timestamp" data-t="00:01:27">[00:01:27]</a>.

## The Enterprise AI Customer Journey
OpenAI typically observes the AI customer journey in three phases, though not necessarily in sequence <a class="yt-timestamp" data-t="00:01:47">[00:01:47]</a>:

1.  **Building an AI-Enabled Workforce:** This initial step involves getting AI into the hands of employees to become AI-literate and use AI daily in their work <a class="yt-timestamp" data-t="00:01:54">[00:01:54]</a>. OpenAI's ChatGPT is often the starting point for this <a class="yt-timestamp" data-t="00:02:30">[00:02:30]</a>.
2.  **Automating AI Operations:** Enterprises graduate to this phase by building internal use cases for automation or co-pilot type applications <a class="yt-timestamp" data-t="00:02:11">[00:02:11]</a>. While ChatGPT can partially assist, the API is utilized for more complex use cases requiring customization <a class="yt-timestamp" data-t="00:02:38">[00:02:38]</a>.
3.  **Infusing AI into End Products:** The final step involves integrating AI into end-user-facing products, primarily through API use cases <a class="yt-timestamp" data-t="00:02:22">[00:02:22]</a>. This aligns with [[ai_in_enterprise_applications | AI in enterprise applications]] and [[integrating_ai_into_business_operations | integrating AI into business operations]] concepts.

## Crafting an Enterprise AI Strategy
OpenAI's approach to strategy development in enterprises involves a few key steps <a class="yt-timestamp" data-t="00:03:07">[00:03:07]</a>:

1.  **Strategic Guidance (Top-Down):** The focus is not merely on an AI strategy but on the broader business strategy, with OpenAI helping to integrate technology to meet those business goals <a class="yt-timestamp" data-t="00:03:17">[00:03:17]</a>.
2.  **Use Case Identification:** Identify one or two impactful, high-value use cases to begin with, scoping them out for successful delivery <a class="yt-timestamp" data-t="00:03:36">[00:03:36]</a>.
3.  **Building Divisional Capability:** Enable teams and infuse AI across the organization through enablement, building Centers of Excellence, or establishing centralized technological platforms <a class="yt-timestamp" data-t="00:03:52">[00:03:52]</a>.

## The Use Case Journey: An Illustrative Example
OpenAI outlines a typical use case journey, often spanning about three months <a class="yt-timestamp" data-t="00:04:28">[00:04:28]</a>:

1.  **Ideation & Scoping:** Involves initial ideation, detailed scoping, architectural review to determine how AI fits into the existing stack, and clear definition of success metrics and KPIs <a class="yt-timestamp" data-t="00:04:40">[00:04:40]</a>.
2.  **Development:** The most time-intensive phase, focusing on iterative improvement through prompting strategies, RAG (Retrieval-Augmented Generation), and other techniques <a class="yt-timestamp" data-t="00:04:53">[00:04:53]</a>. OpenAI's team closely collaborates through workshops, office hours, and paired programming sessions <a class="yt-timestamp" data-t="00:05:06">[00:05:06]</a>.
3.  **Testing & Evaluation:** Utilizes defined evaluations to conduct A/B testing and beta rollouts to understand practical performance <a class="yt-timestamp" data-t="00:05:22">[00:05:22]</a>.
4.  **Production:** The final stage involves launch rollout, scale optimization testing to ensure functionality for many end-users, and ongoing maintenance <a class="yt-timestamp" data-t="00:05:37">[00:05:37]</a>.

### Partnership Benefits with OpenAI
OpenAI deploys a dedicated team and expects partners to do the same <a class="yt-timestamp" data-t="00:05:55">[00:05:55]</a>. Key benefits of this partnership include:
*   **Early Access to Models and Features:** Provides insights into upcoming developments, typically within the next two quarters <a class="yt-timestamp" data-t="00:06:05">[00:06:05]</a>.
*   **Access to Internal Experts:** Collaboration with research, engineering, and product teams to accelerate progress <a class="yt-timestamp" data-t="00:06:35">[00:06:35]</a>.
*   **Joint Roadmap Sessions:** Ensures alignment with the partner's future roadmap <a class="yt-timestamp" data-t="00:06:42">[00:06:42]</a>.

## Case Study: Morgan Stanley
OpenAI partnered with Morgan Stanley to build an internal knowledge assistant for their wealth managers <a class="yt-timestamp" data-t="00:06:54">[00:06:54]</a>. This assistant allowed wealth managers to query a large corpus of knowledge, including research reports and stock ticker data, to provide highly accurate information to clients <a class="yt-timestamp" data-t="00:07:00">[00:07:00]</a>.

Initially, accuracy was around 45% <a class="yt-timestamp" data-t="00:07:19">[00:07:19]</a>. Through collaboration, OpenAI introduced methods like:
*   Hydra retrieval <a class="yt-timestamp" data-t="00:07:26">[00:07:26]</a>
*   Fine-tuning and embeddings <a class="yt-timestamp" data-t="00:07:28">[00:07:28]</a>
*   Different chunking strategies <a class="yt-timestamp" data-t="00:07:29">[00:07:29]</a>

These improvements led to 85% accuracy <a class="yt-timestamp" data-t="00:07:37">[00:07:37]</a>. Further enhancements with prompt engineering and query expansion pushed accuracy to 98%, significantly exceeding their 90% goal <a class="yt-timestamp" data-t="00:07:40">[00:07:40]</a>. This demonstrates effective [[using_existing_enterprise_systems_for_ai_integration | using existing enterprise systems for AI integration]].

## The Rise of AI Agents
OpenAI anticipates 2025 to be the "year of [[agentic_enterprise_and_ai_agents | Agents]]", where GenAI truly graduates from an assistant to a co-worker <a class="yt-timestamp" data-t="00:08:02">[00:08:02]</a>. They have identified patterns and anti-patterns in agent development from working with customers building state-of-the-art agents and their own agentic products <a class="yt-timestamp" data-t="00:08:26">[00:08:26]</a>.

### Defining an AI Agent
OpenAI defines an [[agentic_enterprise_and_ai_agents | agent]] as an AI application comprising <a class="yt-timestamp" data-t="00:09:02">[00:09:02]</a>:
*   A model with instructions (usually a prompt) <a class="yt-timestamp" data-t="00:09:04">[00:09:04]</a>.
*   Access to tools for information retrieval and external system interaction <a class="yt-timestamp" data-t="00:09:11">[00:09:11]</a>.
*   An encapsulated execution loop whose termination is controlled by the model itself <a class="yt-timestamp" data-t="00:09:16">[00:09:16]</a>.

In each execution cycle, the agent receives natural language instructions, decides whether to issue tool calls, runs those tools, synthesizes a response, and provides an answer to the user. The agent may also determine when its objective is met and terminate the loop <a class="yt-timestamp" data-t="00:09:24">[00:09:24]</a>.

## Lessons Learned Building Agents
OpenAI shares four key lessons for [[building_and_scaling_ai_use_cases_for_enterprises | building and scaling AI use cases]] with [[agentic_enterprise_and_ai_agents | agents]] <a class="yt-timestamp" data-t="00:09:50">[00:09:50]</a>:

### 1. Use Abstractions Minimally
*   **Start with Primitives:** Begin by making raw API calls, logging results, outputs, and failures to understand how the task decomposes and where failures occur <a class="yt-timestamp" data-t="00:10:07">[00:10:07]</a>. This helps in understanding constraints and optimizing solutions <a class="yt-timestamp" data-t="00:10:48">[00:10:48]</a>.
*   **Introduce Abstraction When Necessary:** Abstractions should only be introduced when there's a clear need to avoid reinventing the wheel (e.g., re-implementing an embedding strategy or model graders) <a class="yt-timestamp" data-t="00:11:05">[00:11:05]</a>.
*   **Focus on Data and Failure Points:** Developing scalable agents is less about choosing the right framework and more about understanding data, failure points, and constraints <a class="yt-timestamp" data-t="00:11:23">[00:11:23]</a>.

> [!tip] Start Simple, Optimize, and Abstract When it Improves the System
> First build with primitives to understand the task decomposition and failure points, then introduce abstraction only when you find yourself reinventing the wheel or when it clearly makes the system better <a class="yt-timestamp" data-t="00:10:53">[00:10:53]</a>.

### 2. Start Simple (Single Agent First)
*   **Avoid Jumping to Multi-Agent Systems:** Designing complex multi-agent systems too early introduces too many unknowns and provides limited immediate insight <a class="yt-timestamp" data-t="00:11:48">[00:11:48]</a>.
*   **Start with a Single, Purpose-Built Agent:** Begin with a single agent designed for a specific task, deploy it with limited users, and observe its performance <a class="yt-timestamp" data-t="00:12:08">[00:12:08]</a>.
*   **Identify Bottlenecks Incrementally:** This approach allows for the identification of real bottlenecks (hallucinations, low adoption due to latency, inaccuracy) and incremental improvements based on user needs <a class="yt-timestamp" data-t="00:12:21">[00:12:21]</a>.
*   **Complexity Increases with Discovered Failure Cases:** Complexity should be increased as more intense failure cases and constraints are discovered, with the goal being a functional system, not necessarily a complicated one <a class="yt-timestamp" data-t="00:12:44">[00:12:44]</a>.

### 3. Network of Agents and Handoffs
*   **Handle Complex Tasks with Networks:** For more complex tasks, a network of [[agentic_enterprise_and_ai_agents | agents]] can be used. This is a collaborative system where multiple specialized agents work together to resolve complex requests or perform interrelated tasks <a class="yt-timestamp" data-t="00:13:07">[00:13:07]</a>.
*   **Utilize Handoffs:** Handoffs are the process by which one agent transfers control of an active conversation to another agent <a class="yt-timestamp" data-t="00:13:38">[00:13:38]</a>. This is similar to a phone call transfer but preserves the entire conversation history, allowing the new agent to seamlessly continue <a class="yt-timestamp" data-t="00:13:53">[00:13:53]</a>.
*   **Example: Automated Customer Service:** A fully automated customer service flow can be implemented with a network of agents and handoffs. Different models can be assigned to different tasks (e.g., GPT-4o mini for triage, GPT-4o for managing disputes, O3 mini for accuracy-sensitive tasks like refund eligibility) <a class="yt-timestamp" data-t="00:14:03">[00:14:03]</a>. Handoffs maintain context while swapping out the model, prompt, and tool definitions <a class="yt-timestamp" data-t="00:14:39">[00:14:39]</a>. This concept relates to [[OpenAIs Agents SDK | OpenAI's Agents SDK]].

### 4. Guardrails
*   **Definition:** Guardrails are mechanisms that enforce safety, security, and reliability within an application, preventing misuse and maintaining system integrity <a class="yt-timestamp" data-t="00:14:57">[00:14:57]</a>.
*   **Simple, Focused Instructions:** Keeping model instructions simple and focused on the target task ensures maximum interoperability and predictable accuracy/performance improvements <a class="yt-timestamp" data-t="00:15:12">[00:15:12]</a>.
*   **Parallel Guardrails:** Guardrails should generally not be part of main prompts but run in parallel <a class="yt-timestamp" data-t="00:15:25">[00:15:25]</a>. The availability of faster and cheaper models like GPT-4o mini makes this more accessible <a class="yt-timestamp" data-t="00:15:33">[00:15:33]</a>.
*   **Deferred High-Stakes Actions:** High-stakes tool calls or user responses (e.g., issuing refunds, sharing personal account info) should be deferred until all guardrails have returned their results <a class="yt-timestamp" data-t="00:15:42">[00:15:42]</a>.

> [!summary] Key Takeaways for Building Agents
> 1.  Use abstractions minimally <a class="yt-timestamp" data-t="00:16:12">[00:16:12]</a>.
> 2.  Start with a single agent <a class="yt-timestamp" data-t="00:16:14">[00:16:14]</a>.
> 3.  Graduate to a network of [[agentic_enterprise_and_ai_agents | Agents]] for more intense scenarios <a class="yt-timestamp" data-t="00:16:17">[00:16:17]</a>.
> 4.  Keep prompts simple and focused on the happy path, using guardrails to handle edge cases <a class="yt-timestamp" data-t="00:16:19">[00:16:19]</a>.

This comprehensive approach supports [[implementing_ai_in_enterprises | implementing AI in enterprises]] and the broader [[integration_of_ai_in_business_operations | integration of AI in business operations]].