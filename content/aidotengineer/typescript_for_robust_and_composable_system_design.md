---
title: TypeScript for robust and composable system design
videoId: sXXl3YMU7ZI
---

From: [[aidotengineer]] <br/> 

Developing AI-native customer support platforms, especially those that interact directly with end-users and rely on large language models (LLMs) in production, requires systems that operate reliably under uncertain conditions <a class="yt-timestamp" data-t="00:00:07">[00:00:07]</a>. Managing this complexity necessitates robust, type-safe, and composable system design <a class="yt-timestamp" data-t="00:00:16">[00:00:16]</a>. While the TypeScript language provides a strong foundation, it can fall short when dealing with challenges like unreliable APIs, intricate system dependencies, non-deterministic model outputs, and long-running workflows <a class="yt-timestamp" data-t="00:00:26">[00:00:26]</a>.

To address these challenges, the [[Functional programming principles with TypeScript and Effect | Effect]] library is used, which offers tools to confidently handle such situations as platforms evolve <a class="yt-timestamp" data-t="00:00:36">[00:00:36]</a>.

## Key Features of Effect for Robust Design

[[Functional programming principles with TypeScript and Effect | Effect]] provides several critical features for [[Building reliable AI systems using Effect TypeScript | building reliable AI systems]]:
*   **Strong Type Guarantees** across the entire stack <a class="yt-timestamp" data-t="00:00:44">[00:00:44]</a>.
*   **Powerful Composition Primitives** <a class="yt-timestamp" data-t="00:00:48">[00:00:48]</a>.
*   **Built-in Concurrency, Streaming, Interruptions, and Retry Mechanisms** <a class="yt-timestamp" data-t="00:00:50">[00:00:50]</a>.
*   **Structured Error Modeling** <a class="yt-timestamp" data-t="00:00:54">[00:00:54]</a>.
*   **Clean Dependency Injection System** for easier testing and modernization <a class="yt-timestamp" data-t="00:00:57">[00:00:57]</a>.
*   **Easy Observability** via OpenTelemetry <a class="yt-timestamp" data-t="00:01:02">[00:01:02]</a>.

Beyond technical features, [[Functional programming principles with TypeScript and Effect | Effect]] promotes stable, testable, and maintainable code at scale <a class="yt-timestamp" data-t="00:01:07">[00:01:07]</a>. It can be gradually adopted into existing codebases and feels like a natural extension of TypeScript itself <a class="yt-timestamp" data-t="00:01:14">[00:01:14]</a>.

## Architectural Implementation

[[Functional programming principles with TypeScript and Effect | Effect]] is utilized across the entire stack <a class="yt-timestamp" data-t="00:01:23">[00:01:23]</a>:
*   **React Front End**: Powers dashboards, agent IDs, knowledge management, insights, analytics, and SDKs <a class="yt-timestamp" data-t="00:01:28">[00:01:28]</a>.
*   **Internal RPC Server**: Handles application logic, built on Effect RPC and a modified Tanstack Query on the front end <a class="yt-timestamp" data-t="00:01:37">[00:01:37]</a>.
*   **Public API Server**: Uses Effect HTTP with autogenerated OpenAPI documentation from annotated schemas <a class="yt-timestamp" data-t="00:01:47">[00:01:47]</a>.
*   **Data Processing Engine**: Syncs data from CRM, documents, and databases, processing it for real-time analytics and reporting <a class="yt-timestamp" data-t="00:01:53">[00:01:53]</a>.
*   **Agent Workflows**: Written in a custom domain-specific language (DSL) built on [[Functional programming principles with TypeScript and Effect | Effect]], allowing the mixing of deterministic and non-deterministic behavior <a class="yt-timestamp" data-t="00:02:00">[00:02:00]</a>.
*   **Database**: PostgreSQL is used for both data and vector storage, with Effect SQL handling queries <a class="yt-timestamp" data-t="00:02:09">[00:02:09]</a>.

### Effect Schemas

All components are modeled using Effect Schemas <a class="yt-timestamp" data-t="00:02:15">[00:02:15]</a>. This provides:
*   Runtime validation <a class="yt-timestamp" data-t="00:02:18">[00:02:18]</a>.
*   Encoding and decoding <a class="yt-timestamp" data-t="00:02:19">[00:02:19]</a>.
*   Type-safe input and output handling across the stack <a class="yt-timestamp" data-t="00:02:20">[00:02:20]</a>.
*   Autogenerated documentation <a class="yt-timestamp" data-t="00:02:23">[00:02:23]</a>.

## Agent Design with Effect

[[Agentic architectures and systems design | Agents]] are designed as planners that take user input, devise a plan, select the appropriate action, workflow, or sub-agent, execute it, and repeat until the task is complete <a class="yt-timestamp" data-t="00:02:28">[00:02:28]</a>. This system is built using a custom DSL on [[Functional programming principles with TypeScript and Effect | Effect]]'s functional pipe-based system <a class="yt-timestamp" data-t="00:03:14">[00:03:14]</a>, enabling clear and composable expression of:
*   Branching <a class="yt-timestamp" data-t="00:02:24">[00:02:24]</a>
*   Sequencing <a class="yt-timestamp" data-t="00:02:24">[00:02:24]</a>
*   Retries <a class="yt-timestamp" data-t="00:02:26">[00:02:26]</a>
*   State transitions <a class="yt-timestamp" data-t="00:02:27">[00:02:27]</a>
*   Memory <a class="yt-timestamp" data-t="00:02:28">[00:02:28]</a>

Key components of this design include:
*   **Actions**: Small, focused units of execution, similar to [[Model Context Protocol and tool integration | tool calls]], e.g., fetching payment info or searching logs <a class="yt-timestamp" data-t="00:02:40">[00:02:40]</a>.
*   **Workflows**: Deterministic multi-step processes, such as cancelling a subscription (collecting reasons, offering retention, checking eligibility, performing cancellation) <a class="yt-timestamp" data-t="00:02:51">[00:02:51]</a>.
*   **Sub-agents**: Groups of related actions and workflows into larger domain-specific modules, like a billing agent or a log retrieval agent <a class="yt-timestamp" data-t="00:03:03">[00:03:03]</a>.

## Reliability Mechanisms

For mission-critical systems, reliability is paramount <a class="yt-timestamp" data-t="00:03:32">[00:03:32]</a>. [[Functional programming principles with TypeScript and Effect | Effect]] facilitates robust operations through:
*   **LLM Provider Failover**: If one LLM provider fails, the system falls back to another with similar performance characteristics (e.g., GPT-4 mini to GD flash 2.0 for [[Dynamic vs static tool calling | tool calling]]) <a class="yt-timestamp" data-t="00:03:36">[00:03:36]</a>. This is modeled with retry policies that track state to avoid retrying failed providers <a class="yt-timestamp" data-t="00:03:47">[00:03:47]</a>.
*   **Token Stream Duplication**: When answers are streamed to the end-user, token streams are duplicated, sending one directly to the user and another for internal storage (e.g., analytics) <a class="yt-timestamp" data-t="00:03:55">[00:03:55]</a>.
*   **Testing with Dependency Injection**: Heavy use of dependency injection allows mocking LLM providers and simulating failure scenarios, easily swapping services with mock versions without affecting system internals <a class="yt-timestamp" data-t="00:04:09">[00:04:09]</a>.

## Developer Experience (DX)

[[Functional programming principles with TypeScript and Effect | Effect]] significantly enhances the developer experience for [[Agentic architectures and systems design | building agentic systems]]:
*   **Schema-Centric Development**: Input, output, and error types are defined upfront with powerful encoding and decoding <a class="yt-timestamp" data-t="00:04:32">[00:04:32]</a>. This provides strong type safety guarantees and automatic documentation <a class="yt-timestamp" data-t="00:04:40">[00:04:40]</a>.
*   **Dependency Injection**: Services are provided at the system's entry point, allowing for easy composition and mocking for testing <a class="yt-timestamp" data-t="00:04:48">[00:04:48]</a>. Dependencies are guaranteed at the type level at compile time <a class="yt-timestamp" data-t="00:04:59">[00:04:59]</a>.
*   **Modular and Composable Services**: Services are designed to be modular and composable, enabling easy overriding of behavior or swapping implementations without altering internal system logic <a class="yt-timestamp" data-t="00:05:06">[00:05:06]</a>.
*   **Strong Guard Rails**: [[Functional programming principles with TypeScript and Effect | Effect]] helps prevent common mistakes, allowing engineers new to TypeScript to quickly become productive and making it harder to fall into bad patterns after the initial learning curve <a class="yt-timestamp" data-t="00:05:14">[00:05:14]</a>.

## Lessons Learned and Considerations

While powerful, using [[Functional programming principles with TypeScript and Effect | Effect]] effectively requires discipline <a class="yt-timestamp" data-t="00:05:31">[00:05:31]</a>.
*   **Error Handling**: It's easy to accidentally catch errors upstream or out of sight, leading to silent loss of important failures if not careful <a class="yt-timestamp" data-t="00:05:49">[00:05:49]</a>.
*   **Dependency Injection at Scale**: Tracing where services are provided, especially across multiple layers or subsystems, can become challenging <a class="yt-timestamp" data-t="00:05:57">[00:05:57]</a>.
*   **Learning Curve**: [[Functional programming principles with TypeScript and Effect | Effect]] is a large ecosystem with many concepts and tools, which can be overwhelming initially <a class="yt-timestamp" data-t="00:06:10">[00:06:10]</a>. However, once past this initial bump, concepts click, and benefits compound <a class="yt-timestamp" data-t="00:06:17">[00:06:17]</a>.
*   **Not Magic**: [[Functional programming principles with TypeScript and Effect | Effect]] helps build predictable and resilient systems, but it's not a silver bullet; thoughtful design is still required <a class="yt-timestamp" data-t="00:06:27">[00:06:27]</a>.

## Incremental Adoption and Value

A significant advantage of [[Functional programming principles with TypeScript and Effect | Effect]] is its incremental adoptability <a class="yt-timestamp" data-t="00:06:37">[00:06:37]</a>. Teams can start with a single service or endpoint and expand from there <a class="yt-timestamp" data-t="00:06:41">[00:06:41]</a>.

[[Benefits of using Effect in TypeScript for AI and LLM systems | Effect is particularly useful for LLM and AI-based systems]], where reliability and coping with non-determinism are crucial <a class="yt-timestamp" data-t="00:06:47">[00:06:47]</a>. It provides the tools to make systems predictable and observable <a class="yt-timestamp" data-t="00:06:53">[00:06:53]</a>. It also integrates the rigor of [[Functional programming principles with TypeScript and Effect | functional programming]] into real-world TypeScript in a practical way, allowing users to gain significant value without being a functional programming purist <a class="yt-timestamp" data-t="00:07:01">[00:07:01]</a>.