---
title: AI sandbox security
videoId: wsFd22SL1s8
---

From: [[aidotengineer]] <br/> 

[[Building AI sandboxes | AI sandboxes]] are critical for the safe and efficient operation of [[ai_agents | AI agents]], particularly given the increasing reliance on tool calling and code execution during inference and training phases <a class="yt-timestamp" data-t="00:00:59">[00:00:59]</a>. They are considered a significant advancement in AI intelligence <a class="yt-timestamp" data-t="00:00:12">[00:00:12]</a>.

## Why AI Sandboxes are Needed
AI models, like GPT-3, often leverage tool calling (e.g., search, code execution) during inference to provide smarter replies to user queries <a class="yt-timestamp" data-t="00:00:59">[00:00:59]</a>. These tool calls necessitate [[building_ai_sandboxes | AI sandboxes]] for execution <a class="yt-timestamp" data-t="00:01:07">[00:01:07]</a>. For reinforcement learning, sandboxes are essential during the training phase to run reward functions at scale <a class="yt-timestamp" data-t="00:01:12">[00:01:12]</a>.

[[AI agents | Agents]] benefit from having a full Linux sandbox, enabling them to debug entire applications using standard Linux commands, backtrack, replan, and work towards goals effectively <a class="yt-timestamp" data-t="00:01:21">[00:01:21]</a>.

## Security Concerns with AI Agents
The code generated by [[ai_agents | AI agents]] or supplied to them is akin to running arbitrary code from sources like GitHub or Stack Overflow on a production server <a class="yt-timestamp" data-t="00:01:40">[00:01:40]</a>. This code could be buggy or malicious, potentially gaining root access and compromising sensitive data belonging to the user or clients <a class="yt-timestamp" data-t="00:01:46">[00:01:46]</a>. Therefore, robust security measures, including strong lockdown mechanisms, are paramount within [[building_ai_sandboxes | AI sandboxes]] <a class="yt-timestamp" data-t="00:01:37">[00:01:37]</a>.

## Arachis: An Open-Source AI Sandbox Solution
Arachis is an open-source code execution and computer use sandboxing service specifically designed for [[ai_agents | AI agents]] <a class="yt-timestamp" data-t="00:00:04">[00:00:04]</a>. It provides a secure, fully customizable, and self-hosted solution for spawning and managing [[building_ai_sandboxes | AI sandboxes]] <a class="yt-timestamp" data-t="00:02:42">[00:02:42]</a>. A key feature is its out-of-the-box support for [[snapshotting_in_ai_sandboxes | backtracking via snapshot and restore]], allowing [[ai_agents | agents]] to checkpoint their progress and avoid starting from scratch after failures in multi-step workflows <a class="yt-timestamp" data-t="00:02:51">[00:02:51]</a>.

### MicroVM-Based Secure Code Execution
[[AI safety and security | Security is paramount]] for [[building_ai_sandboxes | AI sandboxes]] <a class="yt-timestamp" data-t="00:03:20">[00:03:20]</a>. Arachis addresses this by using [[microvms_in_ai_sandboxes | MicroVMs]] as its runtime environment <a class="yt-timestamp" data-t="00:03:25">[00:03:25]</a>. This choice is particularly important for [[ai_agents | coding agents]] in multi-tenant environments where LLM-generated code might access different clients' data <a class="yt-timestamp" data-t="00:21:12">[00:21:12]</a>. The goal is to prevent untrusted code from gaining root access on the server and compromising other client data <a class="yt-timestamp" data-t="00:21:23">[00:21:23]</a>.

#### MicroVMs vs. Containers for Security
Linux containers use namespaces and cgroups to isolate processes, but they still run as native processes directly on top of the host kernel <a class="yt-timestamp" data-t="00:12:20">[00:12:20]</a>. This means a kernel vulnerability could allow a malicious process within a container to attack the host kernel, gain root access, and then access any data on the system <a class="yt-timestamp" data-t="00:12:33">[00:12:33]</a>. While techniques like restricting Linux capabilities and using seccomp filters can reduce the attack surface, they have limitations <a class="yt-timestamp" data-t="00:13:26">[00:13:26]</a>.

Virtualization, on the other hand, provides a stronger primitive for running untrusted code <a class="yt-timestamp" data-t="00:14:49">[00:14:49]</a>. Each Virtual Machine (VM) has its own guest user space and guest kernel, isolating processes within their own kernel and user space <a class="yt-timestamp" data-t="00:15:05">[00:15:05]</a>. This significantly reduces the attack surface for reaching the host kernel compared to containers <a class="yt-timestamp" data-t="00:15:10">[00:15:10]</a>.

[[MicroVMs in AI sandboxes | MicroVMs]] like CrossVM, Firecracker, and Cloud Hypervisor are a newer generation of VMMs designed for enhanced [[ai_safety_and_security | security]] and performance <a class="yt-timestamp" data-t="00:18:32">[00:18:32]</a>:
*   **Memory Safety**: Many [[microvms_in_ai_sandboxes | MicroVMs]] are written in Rust, which provides memory-safe implementations, mitigating risks associated with memory-safety bugs in traditional C-based VMMs <a class="yt-timestamp" data-t="00:18:57">[00:18:57]</a>.
*   **Jailing Emulated Devices**: They can jail emulated devices (e.g., block, network) separately, restricting their access to only relevant system calls <a class="yt-timestamp" data-t="00:19:14">[00:19:14]</a>. This means compromising one device doesn't grant access to others <a class="yt-timestamp" data-t="00:19:22">[00:19:22]</a>.
*   **Minimal Footprint**: [[MicroVMs in AI sandboxes | MicroVMs]] support only essential architectures and devices, resulting in less code and fewer code paths, which translates to faster boot times and lower memory consumption <a class="yt-timestamp" data-t="00:20:03">[00:20:03]</a>.

Arachis specifically chose Cloud Hypervisor as its [[microvms_in_ai_sandboxes | MicroVM]] VMM due to its general-purpose [[enterprise_ai_within_security_boundaries | enterprise]] focus, support for hot plugging devices, GPU support, and snapshot capabilities <a class="yt-timestamp" data-t="00:22:40">[00:22:40]</a>.

### File System Security
To protect the sandbox's root file system from malicious or buggy code, Arachis employs an overlay file system <a class="yt-timestamp" data-t="00:24:40">[00:24:40]</a>. This setup includes a shared, read-only base layer (root FS) that is common across all sandboxes <a class="yt-timestamp" data-t="00:25:03">[00:25:03]</a>. On top of this, each sandbox receives its own read-write layer where all new files and modifications are stored <a class="yt-timestamp" data-t="00:25:11">[00:25:11]</a>. When a sandbox is [[snapshotting_in_ai_sandboxes | snapshotted]], only this read-write layer is persisted, ensuring the base layer remains protected and shared <a class="yt-timestamp" data-t="00:25:31">[00:25:31]</a>.

### Networking and Port Forwarding
Each sandbox in Arachis runs within a [[microvms_in_ai_sandboxes | MicroVM]] with its own isolated networking <a class="yt-timestamp" data-t="00:27:12">[00:27:12]</a>. This setup involves:
*   **Unique Tap Device**: Each sandbox receives a unique virtual network interface (tap device) <a class="yt-timestamp" data-t="00:27:21">[00:27:21]</a>.
*   **Linux Bridge**: All tap devices are connected to a Linux bridge on the host server <a class="yt-timestamp" data-t="00:27:34">[00:27:34]</a>.
*   **Port Forwarding**: Arachis automatically handles port forwarding from the host to services running inside the sandbox (e.g., code server, VNC server), eliminating the need for manual IP table or firewall configurations <a class="yt-timestamp" data-t="00:27:44">[00:27:44]</a>. This allows easy access to the sandbox's GUI (e.g., Chrome via VNC) and code execution <a class="yt-timestamp" data-t="00:04:15">[00:04:15]</a>.

### Snapshots and Persistence
[[Snapshotting in AI sandboxes | Snapshotting]] is a crucial feature for [[ai_agents | AI agents]] to handle multi-step workflows where failures are common <a class="yt-timestamp" data-t="00:33:01">[00:33:01]</a>. Arachis allows agents to save the entire running state of a sandbox, including guest memory and the read-write file system layer <a class="yt-timestamp" data-t="00:33:30">[00:33:30]</a>. This means any files created, processes spawned, or even GUI windows opened will be restored exactly as they were <a class="yt-timestamp" data-t="00:33:41">[00:33:41]</a>. Agents can backtrack to a "last good checkpoint," replan, and continue their workflow, leading to more reliable and complex task execution <a class="yt-timestamp" data-t="00:34:01">[00:34:01]</a>. The snapshotting process involves pausing the VM, dumping guest memory, persisting the read-write overlay FS, and then resuming the VM <a class="yt-timestamp" data-t="00:34:44">[00:34:44]</a>.

## Ongoing Work and Future Enhancements
Current development efforts for Arachis include:
*   Achieving sub-second boot times <a class="yt-timestamp" data-t="00:39:14">[00:39:14]</a>.
*   Enhancing [[snapshotting_in_ai_sandboxes | snapshot]] and persistence support, potentially by moving to Btrfs for native incremental snapshot awareness <a class="yt-timestamp" data-t="00:39:24">[00:39:24]</a>.
*   Improving dynamic memory and resource management (e.g., ballooning, hot-plugging of memory) to pack more sandboxes onto a single server <a class="yt-timestamp" data-t="00:39:35">[00:39:35]</a>.

These continuous improvements further strengthen the [[ai_safety_and_security | AI safety and security]] framework provided by Arachis, ensuring robust and scalable environments for [[ai_deployment_in_private_clouds | AI deployment in private clouds]] and addressing the [[challenges_of_ai_agents_in_security | challenges of AI agents in security]].