---
title: Features and architecture of Arachis
videoId: wsFd22SL1s8
---

From: [[aidotengineer]] <br/> 

Arachis is an open-source code execution and computer use sandboxing service for [[agentic_architectures_for_generative_ai | AI agents]] <a class="yt-timestamp" data-t="00:00:04">[00:00:04]</a>. Developed by solo founder Abhishek, it is built at the intersection of operating systems, sandboxes, and [[agentic_architectures_for_generative_ai | AI agents]] <a class="yt-timestamp" data-t="00:00:48">[00:00:48]</a>. The project aims to be the next big unlock in intelligence by providing a secure and flexible environment for [[agentic_architectures_for_generative_ai | AI agents]] <a class="yt-timestamp" data-t="00:00:12">[00:00:12]</a>.

## Why AI Sandboxes are Needed

AI sandboxes are crucial for several reasons:
*   **Tool Calling** The latest models, such as GPT-3, leverage tool calling (like search or code execution) during inference to generate smarter replies to user queries <a class="yt-timestamp" data-t="00:00:59">[00:00:59]</a>. These tool calls necessitate AI sandboxes for execution <a class="yt-timestamp" data-t="00:01:07">[00:01:07]</a>.
*   **Reinforcement Learning** During the training phase of reinforcement learning, sandboxes are needed to run reward functions at scale <a class="yt-timestamp" data-t="00:01:12">[00:01:12]</a>.
*   **Enhanced Agent Capabilities** A full Linux sandbox significantly extends the capabilities of [[agentic_architectures_for_generative_ai | AI agents]] <a class="yt-timestamp" data-t="00:01:21">[00:01:21]</a>. For example, during code generation, agents can debug entire applications using Linux commands like `ps` and `lsof` <a class="yt-timestamp" data-t="00:01:25">[00:01:25]</a>. This allows them to backtrack, replan, and work towards a goal more effectively <a class="yt-timestamp" data-t="00:01:32">[00:01:32]</a>.
*   **Security** Agent-generated code, like any code from GitHub or Stack Overflow, can be buggy or malicious <a class="yt-timestamp" data-t="00:01:40">[00:01:40]</a>. Running such code on a host or production server without isolation risks root access, data exposure, and potential system compromise <a class="yt-timestamp" data-t="00:01:46">[00:01:46]</a>. Sandboxes provide the necessary lockdown <a class="yt-timestamp" data-t="00:01:53">[00:01:53]</a>.

## Features of Arachis

Arachis provides a secure, fully customizable, and self-hosted solution for spawning and managing [[agentic_architectures_for_generative_ai | AI sandboxes]] <a class="yt-timestamp" data-t="00:02:42">[00:02:42]</a>. Key features include:

### MicroVM-based Secure Code Execution
Arachis utilizes microVMs as its runtime environment to ensure security <a class="yt-timestamp" data-t="00:03:22">[00:03:22]</a>. This prevents malicious or buggy code generated by [[agentic_architectures_for_generative_ai | AI agents]] from gaining root access and compromising user or client data <a class="yt-timestamp" data-t="00:03:38">[00:03:38]</a>.

### Speed
Speed is paramount for [[agentic_architectures_for_generative_ai | AI sandboxes]] <a class="yt-timestamp" data-t="00:03:48">[00:03:48]</a>. Arachis boasts fast boot times, currently under 7 seconds, which is significantly faster than a traditional VM (40 seconds on macOS) <a class="yt-timestamp" data-t="00:03:55">[00:03:55]</a>. There is ongoing work to reduce this to under one second <a class="yt-timestamp" data-t="00:04:02">[00:04:02]</a>. Snapshots are also very fast, taking single-digit seconds and continuously improving <a class="yt-timestamp" data-t="00:04:08">[00:04:08]</a>.

### Port Forwarding
Arachis handles all necessary port forwarding, allowing easy access to code execution or browser use via a public URL and port, without manual configuration of IP tables or firewalls <a class="yt-timestamp" data-t="00:04:15">[00:04:15]</a>.

### Easy Computer Use Workflows
Chrome is pre-installed in the sandbox, along with a VNC server, enabling easy graphical user interface (GUI) access for [[agentic_architectures_for_generative_ai | agent]] workflows <a class="yt-timestamp" data-t="00:04:31">[00:04:31]</a>.

### Backtracking via Snapshot and Restore
Arachis supports snapshot and restore functionality, allowing [[agentic_architectures_for_generative_ai | agents]] to checkpoint their progress <a class="yt-timestamp" data-t="00:04:48">[00:04:48]</a>. If multi-step workflows fail, agents can restore an old snapshot instead of starting from scratch <a class="yt-timestamp" data-t="00:04:57">[00:04:57]</a>. This leads to more reliable, higher-order complex task execution by [[agentic_architectures_for_generative_ai | agents]] <a class="yt-timestamp" data-t="00:05:01">[00:05:01]</a>.

### Dead Simple and Ubiquitous API
Arachis offers a Python API, a Golang client, an MCP server, and an OpenAPI-compatible YAML file <a class="yt-timestamp" data-t="00:05:10">[00:05:10]</a>. This allows for client generation in any desired language <a class="yt-timestamp" data-t="00:05:18">[00:05:18]</a>.

### Configurable with Docker Tooling
Users can customize the binaries and packages installed in the sandbox using existing Docker commands and a Dockerfile <a class="yt-timestamp" data-t="00:05:24">[00:05:24]</a>. This provides complete control over the sandbox environment <a class="yt-timestamp" data-t="00:05:33">[00:05:33]</a>.

## Architecture of Arachis

The high-level [[ai_application_frameworks_and_architecture | architecture]] of Arachis involves a REST server that spawns and manages microVM sandboxes <a class="yt-timestamp" data-t="00:05:40">[00:05:40]</a>. Each sandbox runs a VNC server and a code server, with port forwarding exposing the VNC server for GUI access via a VNC client <a class="yt-timestamp" data-t="00:05:47">[00:05:47]</a>.

Arachis is tied to Linux because the microVM technology it uses relies on `dev/kvm`, the Linux virtualization device <a class="yt-timestamp" data-t="00:06:19">[00:06:19]</a>.

### Linux Sandboxing Background

Arachis's choice of microVMs is rooted in various Linux sandboxing techniques:

#### Linux Execution Model
On Linux, a thread is the smallest unit of execution, represented by a `task_struct` in the kernel's scheduler run queue <a class="yt-timestamp" data-t="00:08:21">[00:08:21]</a>. A process is a logical construct of multiple threads, sharing resources like the page table <a class="yt-timestamp" data-t="00:08:42">[00:08:42]</a>. The kernel provides privileged access to hardware, requiring special instructions (system calls) to switch to kernel mode for privileged operations <a class="yt-timestamp" data-t="00:08:56">[00:08:56]</a>.

#### Containers
Containers address the problem of packaging an application's dependencies with its core logic, allowing arbitrary user code to run on a machine <a class="yt-timestamp" data-t="00:10:13">[00:10:13]</a>. Technically, a container is a collection of namespaces (e.g., process, mount, network) that abstract different resources, giving processes inside a bound view of their own resources <a class="yt-timestamp" data-t="00:10:32">[00:10:32]</a>. While the host can peek into a child container's namespace, the container cannot look upwards into the host's namespace <a class="yt-timestamp" data-t="00:11:08">[00:11:08]</a>. Cgroups are used alongside namespaces to control resource access (e.g., memory, CPU percentage) <a class="yt-timestamp" data-t="00:11:41">[00:11:41]</a>.

**Container Security Flaws**: Containers run as native processes on top of the host kernel <a class="yt-timestamp" data-t="00:12:20">[00:12:20]</a>. A kernel vulnerability allows a malicious or buggy process within a container to attack the kernel, gain root access, and compromise the entire system <a class="yt-timestamp" data-t="00:12:33">[00:12:33]</a>.

**Mitigation Techniques for Containers**: To reduce the attack surface, containers can be "jailed" by restricting Linux capabilities (caps) and system calls they can invoke <a class="yt-timestamp" data-t="00:13:19">[00:13:19]</a>. Syscalls can be filtered using `seccomp` <a class="yt-timestamp" data-t="00:14:01">[00:14:01]</a>. Libraries like `minijail` can help in jailing and sandboxing containers <a class="yt-timestamp" data-t="00:14:19">[00:14:19]</a>. However, sandboxing and jailing still have limits and can be bypassed <a class="yt-timestamp" data-t="00:14:31">[00:14:31]</a>.

#### Virtualization
Virtualization provides another primitive for running untrusted code <a class="yt-timestamp" data-t="00:14:49">[00:14:49]</a>. Each Virtual Machine (VM) has its own guest user space and guest kernel, offering greater isolation compared to containers <a class="yt-timestamp" data-t="00:14:53">[00:14:53]</a>. This results in a smaller attack surface to the host kernel <a class="yt-timestamp" data-t="00:15:10">[00:15:10]</a>.

**Linux Virtualization (KVM)**: The process of spawning VMs is managed by a Virtual Machine Monitor (VMM), such as QEMU, CrossVM, or Firecracker <a class="yt-timestamp" data-t="00:15:47">[00:15:47]</a>. The VMM communicates with `dev/kvm`, a Linux kernel device that exposes the processor's virtualization stack, to start VMs and grant access to privileged resources <a class="yt-timestamp" data-t="00:16:01">[00:16:01]</a>. When a VM needs to access host resources (disk, network), it "VM exits" to the host. The VMM handles the request with the host kernel and sends the response back to the guest with a "VM resume" <a class="yt-timestamp" data-t="00:16:56">[00:16:56]</a>. Minimizing VM exits and resumes is critical for performance <a class="yt-timestamp" data-t="00:17:22">[00:17:22]</a>.

#### MicroVMs
MicroVMs differ from traditional VMs in several ways:
*   **Security-First Design**: Pioneered by the CrossVM project at Chrome OS, microVM VMMs are often written in memory-safe languages like Rust, reducing vulnerabilities from memory safety bugs in emulated devices <a class="yt-timestamp" data-t="00:18:38">[00:18:38]</a>. They also jail emulated devices separately, restricting compromise of one device (e.g., block) from affecting others (e.g., network) <a class="yt-timestamp" data-t="00:19:11">[00:19:11]</a>.
*   **Lightweight and Fast Boot**: The "micro" in microVM refers to the VMM process itself <a class="yt-timestamp" data-t="00:19:41">[00:19:41]</a>. Unlike old VMMs (like QEMU) that support many architectures and emulated devices, microVMs (like CrossVM, Firecracker, Cloud Hypervisor) support only one or two architectures (Intel, ARM) and major devices <a class="yt-timestamp" data-t="00:19:54">[00:19:54]</a>. This drastically reduces code paths at boot, leading to blazing-fast boot times and lower memory consumption at runtime <a class="yt-timestamp" data-t="00:20:17">[00:20:17]</a>.

#### Why Arachis Chose MicroVMs
Arachis selected microVMs as its final execution environment for [[agentic_architectures_for_generative_ai | AI sandboxes]] due to:
*   **Security**: Essential for coding agents that may handle multi-tenant environments with LLM-generated code accessing sensitive client data <a class="yt-timestamp" data-t="00:21:02">[00:21:02]</a>.
*   **Fast Boot Times**: Supports the need for quick tool calls and code generation <a class="yt-timestamp" data-t="00:21:38">[00:21:38]</a>.
*   **Snapshotting**: MicroVMs enable fast snapshotting by simply dumping the entire guest memory, a process not as straightforward with containers or GVisor <a class="yt-timestamp" data-t="00:21:43">[00:21:43]</a>.

**VMM Selection**: Arachis specifically chose **Cloud Hypervisor** as its microVM VMM <a class="yt-timestamp" data-t="00:23:04">[00:23:04]</a>.
*   **Cloud Hypervisor vs. Firecracker**: While Firecracker (underpinning AWS Lambda) has a fleshed-out REST API and better jailing, Cloud Hypervisor is a more general-purpose enterprise VMM <a class="yt-timestamp" data-t="00:22:27">[00:22:27]</a>.
*   **Benefits of Cloud Hypervisor**: At the time of choice, it offered hot-plugging of devices (adding/removing RAM at runtime), GPU support, and snapshot support <a class="yt-timestamp" data-t="00:22:44">[00:22:44]</a>. Furthermore, it is not controlled by a single company, fostering a more collaborative software project <a class="yt-timestamp" data-t="00:22:58">[00:22:58]</a>.
*   **GVisor Alternative**: GVisor is another option, closer to a container in performance but with slightly better security. It allows easier GPU access but still carries risks of host kernel attacks <a class="yt-timestamp" data-t="00:23:12">[00:23:12]</a>.

### Detailed Architecture Components

#### Storage / File System
To protect the root file system (rootFS) from untrusted code, Arachis employs a shared, read-only base layer (OverlayFS) for the rootFS, shared between sandboxes <a class="yt-timestamp" data-t="00:25:03">[00:25:03]</a>. On top of this, each sandbox receives its own read-write layer where new files are created <a class="yt-timestamp" data-t="00:25:13">[00:25:13]</a>. When a sandbox is snapshotted, only this read-write layer is persisted, optimizing storage and backup <a class="yt-timestamp" data-t="00:25:31">[00:25:31]</a>.

#### Networking
Each Arachis sandbox runs in a virtual machine with its own isolated networking setup <a class="yt-timestamp" data-t="00:27:09">[00:27:09]</a>. This includes:
*   **Tap Device**: Each sandbox gets a unique virtual networking interface <a class="yt-timestamp" data-t="00:27:19">[00:27:19]</a>.
*   **Linux Bridge**: All tap devices are connected to a Linux bridge on the host server <a class="yt-timestamp" data-t="00:27:32">[00:27:32]</a>.
*   **Port Forwarding**: Arachis automatically forwards ports from the host to the code server or VNC server within the sandbox, simplifying access <a class="yt-timestamp" data-t="00:27:44">[00:27:44]</a>. This involves setting up bridge devices and complex firewall rules using Linux `iptables` commands <a class="yt-timestamp" data-t="00:28:06">[00:28:06]</a>.

#### Customization
Arachis sandboxes are customizable via Docker tooling <a class="yt-timestamp" data-t="00:29:29">[00:29:29]</a>. The default Dockerfile is based on Ubuntu 22.04 and includes standard packages for agents, such as Chrome (booted via systemd), NodeJS, npm, and Python <a class="yt-timestamp" data-t="00:29:46">[00:29:46]</a>. Users can modify this Dockerfile to include any desired binaries or packages <a class="yt-timestamp" data-t="00:30:16">[00:30:16]</a>.

#### Code Execution Server
Arachis is bundled with a code execution server running inside the sandbox <a class="yt-timestamp" data-t="00:31:20">[00:31:20]</a>.
*   **Files API**: Allows uploading and downloading files to and from the sandbox <a class="yt-timestamp" data-t="00:31:27">[00:31:27]</a>.
*   **Command API**: Takes a command, executes it, and returns the output or error in JSON format <a class="yt-timestamp" data-t="00:31:39">[00:31:39]</a>.
*   The fact that this server runs within a secure guest VM increases confidence in exposing such functionality, unlike running it directly on the host OS <a class="yt-timestamp" data-t="00:31:51">[00:31:51]</a>.

#### Snapshotting
Snapshotting allows [[agentic_architectures_for_generative_ai | agents]] to save the entire running state of a sandbox, including guest memory and the read-write layer of the file system <a class="yt-timestamp" data-t="00:33:30">[00:33:30]</a>. Any created files, spawned processes, or even open GUI windows are restored exactly as they were <a class="yt-timestamp" data-t="00:33:39">[00:33:39]</a>.

**Snapshotting Process**:
1.  **Pause VM**: The VM is paused by calling the VMM's pause API <a class="yt-timestamp" data-t="00:34:44">[00:34:44]</a>.
2.  **Dump Guest Memory**: The snapshot API is called to dump the guest's memory <a class="yt-timestamp" data-t="00:34:50">[00:34:50]</a>.
3.  **Persist Read-Write OverlayFS**: The thin read-write overlay file system is manually persisted to save all files created by the agent <a class="yt-timestamp" data-t="00:34:57">[00:34:57]</a>.
4.  **Resume VMM**: The VMM is resumed, allowing the sandbox to continue its operations from where it was paused <a class="yt-timestamp" data-t="00:35:08">[00:35:08]</a>.

This process enables [[agentic_architectures_for_generative_ai | agents]] to backtrack to a good snapshot if they fail, replan, and continue their workflow, leading to more reliable results <a class="yt-timestamp" data-t="00:34:01">[00:34:01]</a>.

## How to Use Arachis

Arachis provides a straightforward Python SDK for interaction <a class="yt-timestamp" data-t="00:35:54">[00:35:54]</a>. After self-hosting Arachis on infrastructure, users can pip install the `arashis` package <a class="yt-timestamp" data-t="00:35:57">[00:35:57]</a>.

Using the SDK:
*   Instantiate a sandbox manager with the Arachis server's IP <a class="yt-timestamp" data-t="00:36:01">[00:36:01]</a>.
*   List running VMs and their metadata (IP, ports) using `list_all` <a class="yt-timestamp" data-t="00:36:09">[00:36:09]</a>.
*   Start a sandbox with `start_sandbox` <a class="yt-timestamp" data-t="00:36:17">[00:36:17]</a>.
*   Run commands and retrieve output/errors <a class="yt-timestamp" data-t="00:36:19">[00:36:19]</a>.
*   Snapshot a VM with a simple `snapshot` call, providing a snapshot ID <a class="yt-timestamp" data-t="00:36:26">[00:36:26]</a>.
*   Destroy a VM when done <a class="yt-timestamp" data-t="00:36:30">[00:36:30]</a>.
*   Restore a checkpoint by calling `restore` with the VM name and snapshot ID <a class="yt-timestamp" data-t="00:36:35">[00:36:35]</a>.

## Demo Example

A demonstration shows Claude Desktop using Arachis via its MCP server to create a Google Docs clone with built-in collaboration <a class="yt-timestamp" data-t="00:37:04">[00:37:04]</a>. Claude pipes commands directly into the Arachis sandbox <a class="yt-timestamp" data-t="00:37:41">[00:37:41]</a>. The demo highlights Arachis's networking setup, enabling real-time collaborative features <a class="yt-timestamp" data-t="00:37:48">[00:37:48]</a>. The sandbox is snapshotted, and then a new feature (dark mode) is added and verified <a class="yt-timestamp" data-t="00:37:51">[00:37:51]</a>. The ability to restore to the previous snapshot without dark mode demonstrates the backtracking functionality <a class="yt-timestamp" data-t="00:38:19">[00:38:19]</a>.

## Ongoing Work

Current development focuses on:
*   Achieving sub-1-second boot times <a class="yt-timestamp" data-t="00:39:14">[00:39:14]</a>.
*   Enhancing snapshot and persistence support, potentially by moving to `btrfs` for incremental snapshots <a class="yt-timestamp" data-t="00:39:24">[00:39:24]</a>.
*   Improving sandbox bin-packing on a single server through dynamic memory and resource management, such as ballooning or hot-plugging/removal of memory at runtime <a class="yt-timestamp" data-t="00:39:35">[00:39:35]</a>.