---
title: Graph databases and technical implementations
videoId: RR5le0K4Wtw
---

From: [[aidotengineer]] <br/> 

Graph databases are a crucial component in advanced AI systems, particularly in the realm of knowledge representation, retrieval, and intelligent agent memory. They offer a systematic method for preserving wisdom by connecting different entities and creating a network of interconnected relationships <a class="yt-timestamp" data-t="02:44:09">[02:44:09]</a>. This approach contrasts with traditional, more isolated data storage methods, providing a comprehensive view of knowledge <a class="yt-timestamp" data-t="03:55:09">[03:55:09]</a>.

## Core Concepts of Graph Databases

A [[Knowledge graph and its role in AI | knowledge graph]] is a network that represents relationships between different entities, which can include people, places, concepts, or events <a class="yt-timestamp" data-t="02:33:40">[02:33:40]</a>. The "edge" of a relationship between two entities is very important, as it can only be fully exploited by graph-based networks or [[Knowledge graph and its role in AI | knowledge graphs]] <a class="yt-timestamp" data-t="03:02:02">[03:02:02]</a>. The core goal in creating a [[Knowledge graph and its role in AI | knowledge graph]] is to establish a "triplet" â€“ defining the relationship between these entities, which is a strength of graph-based systems <a class="yt-timestamp" data-t="03:24:02">[03:24:02]</a> <a class="yt-timestamp" data-t="03:30:00">[03:30:00]</a>.

Unlike semantic RAG systems or vector databases, [[Knowledge graph and its role in AI | knowledge graphs]] capture information and connections between entities in much greater detail, providing a more comprehensive view of the knowledge within a system <a class="yt-timestamp" data-t="03:47:00">[03:47:00]</a> <a class="yt-timestamp" data-t="03:50:00">[03:50:00]</a>. They also have the ability to organize data from multiple sources <a class="yt-timestamp" data-t="04:14:00">[04:14:00]</a>.

## Technical Implementations and Architectures

Building and leveraging graph databases involves several key technical steps, from data processing to advanced retrieval and memory management.

### GraphRAG Systems

[[GraphRAG systems and applications | GraphRAG systems]] are a hybrid approach combining the strengths of [[Knowledge graph and its role in AI | knowledge graphs]] with Retrieval Augmented Generation (RAG). The high-level architecture of a [[GraphRAG systems and applications | GraphRAG system]] involves four main components: data, data processing, graph creation (or semantic embedding vector database creation), and inferencing <a class="yt-timestamp" data-t="04:28:00">[04:28:00]</a> <a class="yt-timestamp" data-t="04:31:00">[04:31:00]</a> <a class="yt-timestamp" data-t="04:39:00">[04:39:00]</a>. This process can be broadly divided into offline (one-time data processing and graph/database creation) and online (querying and response generation) phases <a class="yt-timestamp" data-t="05:00:00">[05:00:00]</a>.

#### Creating Knowledge Graphs
A critical step is creating triplets from unstructured documents <a class="yt-timestamp" data-t="06:21:00">[06:21:00]</a>. This involves using Large Language Models (LLMs) to extract entities and their relationships <a class="yt-timestamp" data-t="06:49:00">[06:49:00]</a> <a class="yt-timestamp" data-t="07:26:00">[07:26:00]</a>. Prompt engineering is crucial here, defining the "ontology" (the types of entities and relationships) based on the specific use case to guide the LLM's extraction and structuring of information into a triplet format <a class="yt-timestamp" data-t="07:40:00">[07:40:00]</a> <a class="yt-timestamp" data-t="07:46:00">[07:46:00]</a>. The quality of these triplets directly impacts the retrieval process; noisy triplets lead to noisy retrieval <a class="yt-timestamp" data-t="08:17:00">[08:17:00]</a>. Developers might spend up to 80% of their time perfecting the ontology to ensure accurate triplets <a class="yt-timestamp" data-t="08:35:00">[08:35:00]</a>.

Alongside graph creation, the semantic vector database is built by chunking documents, converting chunks into vector embeddings using an [[use of embedding models and vector databases | embedding model]], and storing them in a [[use of embedding models and vector databases | vector database]] <a class="yt-timestamp" data-t="08:48:00">[08:48:00]</a> <a class="yt-timestamp" data-t="09:01:00">[09:01:00]</a> <a class="yt-timestamp" data-t="09:10:00">[09:10:00]</a>. Overlap between chunks is important to maintain context <a class="yt-timestamp" data-t="09:20:00">[09:20:00]</a>. The key difference is that semantic vector databases don't exploit the relationships between entities, which [[Knowledge graph and its role in AI | knowledge graphs]] excel at <a class="yt-timestamp" data-t="09:40:00">[09:40:00]</a>.

#### Retrieval in Graph-Based Systems
Retrieval involves querying the [[Knowledge graph and its role in AI | knowledge graph]] to identify relevant nodes and their relationships <a class="yt-timestamp" data-t="10:06:00">[10:06:06]</a>. Simple "single hop" retrieval misses the core advantage of graphs, which is exploiting relationships through multiple nodes or "hops" <a class="yt-timestamp" data-t="10:29:00">[10:29:00]</a>. Deeper traversal provides better context but increases latency, necessitating a balance between depth and performance in production environments <a class="yt-timestamp" data-t="11:02:00">[11:02:00]</a> <a class="yt-timestamp" data-t="11:07:00">[11:07:00]</a>. Tools like NVIDIA's `cuGraph` library can accelerate graph searches, allowing for deeper traversal while reducing latency <a class="yt-timestamp" data-t="11:37:00">[11:37:00]</a>.

### Agent Memory with Graph Databases

Traditional RAG and [[use of embedding models and vector databases | vector databases]] struggle with agent memory because each fact is isolated and immutable, lacking temporal and relational reasoning <a class="yt-timestamp" data-t="40:33:00">[40:33:00]</a> <a class="yt-timestamp" data-t="40:52:00">[40:52:00]</a>. They rely on semantic similarity, which may not align with business relevance or changing user preferences over time <a class="yt-timestamp" data-t="57:05:00">[57:05:00]</a>.

Zep's open-source framework, Graffiti, addresses this by building real-time, dynamic, temporal graphs <a class="yt-timestamp" data-t="41:45:00">[41:45:00]</a>. Graffiti is:
*   **Temporally Aware:** It tracks multiple temporal dimensions for each fact, identifying when a fact becomes valid or invalid, enabling reasoning over time <a class="yt-timestamp" data-t="42:25:00">[42:25:00]</a> <a class="yt-timestamp" data-t="42:50:00">[42:50:00]</a>.
*   **Graph Relational:** It defines explicit relationships between facts, modeling causality (e.g., broken shoes *cause* disappointment, leading to a brand preference change) <a class="yt-timestamp" data-t="43:22:00">[43:22:00]</a> <a class="yt-timestamp" data-t="43:32:00">[43:32:00]</a>. Instead of deleting old facts, it marks them invalid, preserving the history of state changes <a class="yt-timestamp" data-t="43:51:00">[43:51:00]</a>.
*   **Domain-Aware:** Developers can model their business domain using custom entities and edges, allowing agents to retrieve specific and relevant information, avoiding "irrelevant facts" that pollute memory <a class="yt-timestamp" data-t="45:51:00">[45:51:00]</a> <a class="yt-timestamp" data-t="46:13:00">[46:13:00]</a> <a class="yt-timestamp" data-t="56:02:00">[56:02:00]</a>.

Graffiti integrates semantic search and BM25 full-text retrieval to identify subgraphs, which are then traversed and fused for fast and accurate retrieval <a class="yt-timestamp" data-t="44:53:00">[44:53:00]</a>. It offers very low latency retrieval without an LLM in the path, operating in hundreds of milliseconds, unlike some graph RAGs that might take tens of seconds <a class="yt-timestamp" data-t="47:39:00">[47:39:00]</a>.

### Multi-Agent Systems and Knowledge Augmentation (KAG)

Knowledge Augmentation Generations (KAG) systems differ from RAG by enhancing language models with structured [[Knowledge graph and its role in AI | knowledge graphs]] for more accurate and insightful responses that *understand* rather than just *retrieve* <a class="yt-timestamp" data-t="02:27:00">[02:27:00]</a> <a class="yt-timestamp" data-t="02:31:00">[02:31:00]</a>. This is based on a "wisdom graph" concept, where wisdom is the core, actively guiding decisions based on knowledge, experience, and insight, with continuous feedback loops <a class="yt-timestamp" data-t="02:59:00">[02:59:00]</a>.

For practical application, this philosophical model can be mapped to real-world systems, such as a competitive analysis chatbot. Knowledge becomes market data, experience is past campaign performance, insight is industrial trends, and the situation is product sales, all contributing to strategic decision-making <a class="yt-timestamp" data-t="03:06:00">[03:06:00]</a> <a class="yt-timestamp" data-t="03:10:00">[03:10:00]</a>.

Node-RED, a no-code/low-code platform, can be used for prototyping and enabling complex state diagrams with AI agents <a class="yt-timestamp" data-t="03:21:00">[03:21:00]</a>. Advanced techniques like "fusion and decoder" used with [[Knowledge graph and its role in AI | knowledge graphs]] help improve efficiency and reduce hallucination rates in responses <a class="yt-timestamp" data-t="03:32:00">[03:32:00]</a> <a class="yt-timestamp" data-t="03:40:00">[03:40:00]</a>. Benchmarking has shown that such retrieval systems can achieve higher accuracy and faster response times compared to vector search systems <a class="yt-timestamp" data-t="03:41:00">[03:41:00]</a>. These systems can expose the LLM's thought process, handle complex queries across multiple documents ("multihop questions"), and manage complex data formats that challenge vector retrieval <a class="yt-timestamp" data-t="03:46:00">[03:46:00]</a> <a class="yt-timestamp" data-t="03:51:00">[03:51:00]</a> <a class="yt-timestamp" data-t="03:53:00">[03:53:00]</a>.

## Industry Applications and Use Cases

The [[Adoption of knowledge graphs in enterprise AI | adoption of knowledge graphs in enterprise AI]] is growing, with various companies leveraging them for specific applications.

### Evaluation and Optimization
[[Evaluation and performance metrics of graphbased systems | Evaluation and performance metrics of graphbased systems]] are crucial for assessing the effectiveness of RAG workflows. Metrics include faithfulness, answer relevancy, precision, recall, helpfulness, collectiveness, coherence, complexity, and verbosity <a class="yt-timestamp" data-t="12:24:00">[12:24:00]</a>. The Ragas library is a Python tool designed to evaluate RAG workflows end-to-end, assessing response, retrieval, and query interpretation <a class="yt-timestamp" data-t="12:42:00">[12:42:00]</a>. Reward models like Lanimotron 340B can also judge the responses of other LLMs <a class="yt-timestamp" data-t="14:04:00">[14:04:00]</a>.

Optimization strategies for [[GraphRAG systems and applications | GraphRAG systems]] involve:
*   **Data Cleaning:** Removing irrelevant characters (e.g., apostrophes, brackets) from unstructured data can lead to better results in triplet generation <a class="yt-timestamp" data-t="15:51:00">[15:51:00]</a> <a class="yt-timestamp" data-t="16:31:00">[16:31:00]</a>.
*   **LLM Fine-tuning:** Fine-tuning an LLM model (e.g., Llama 3.1) can significantly improve the quality of generated triplets and overall accuracy <a class="yt-timestamp" data-t="15:38:00">[15:38:00]</a> <a class="yt-timestamp" data-t="16:59:00">[16:59:00]</a>.
*   **Retrieval Depth (Hops):** Optimizing the number of hops in graph traversal to balance context richness and latency <a class="yt-timestamp" data-t="10:48:00">[10:48:00]</a>.
*   **Hardware Acceleration:** Using libraries like `cuGraph` integrated with NetworkX can drastically reduce latency for graph algorithms, improving performance when dealing with millions or billions of nodes <a class="yt-timestamp" data-t="11:37:00">[11:37:00]</a> <a class="yt-timestamp" data-t="18:18:00">[18:18:00]</a>.

The decision to use a graph, semantic, or hybrid RAG system depends on the data structure (e.g., retail, FSI, employee databases with good structure are good for graphs) and the complexity of the use case (e.g., requiring understanding of complex relationships) <a class="yt-timestamp" data-t="19:16:00">[19:16:00]</a> <a class="yt-timestamp" data-t="20:00:00">[20:00:00]</a>. Graph-based systems are compute-heavy, so their benefits must justify the cost <a class="yt-timestamp" data-t="20:26:00">[20:26:00]</a>.

### Specific Implementations and Use Cases

*   **NVIDIA's Developer Advocate Team:** This team focuses on creating technical workflows and notebooks, releasing code on GitHub to help developers leverage [[Graph data structures in AI and its benefits | graph data structures in AI and its benefits]] for various applications <a class="yt-timestamp" data-t="01:17:00">[01:17:00]</a>.
*   **Cognify:** This modular framework builds semantic graphs from various data sources (e.g., GitHub API) and allows agents to read, write, and analyze data for tasks like comparing developer profiles for hiring decisions <a class="yt-timestamp" data-t="01:43:47">[01:43:47]</a>. It supports custom graph building and memory association layers inspired by cognitive science <a class="yt-timestamp" data-t="01:45:15">[01:45:15]</a>.
*   **Neo4j MCP Server:** This memory server enables agents to properly recall and log memories by creating entities and relationships in a [[Knowledge graph and its role in AI | knowledge graph]] based on conversations <a class="yt-timestamp" data-t="01:48:45">[01:48:45]</a> <a class="yt-timestamp" data-t="01:51:00">[01:51:00]</a>. It provides rich context through identified relationships, which can be visualized <a class="yt-timestamp" data-t="01:51:17">[01:51:17]</a>.
*   **Cisco's Outshift Multi-Agent Framework:** This system uses a "network [[Knowledge graph and its role in AI | knowledge graph]]" as a digital twin of a production network to reduce failures in change management <a class="yt-timestamp" data-t="02:46:43">[02:46:43]</a>. It leverages multimodal data sources (controllers, devices, config management systems) in various formats (Yang, JSON) <a class="yt-timestamp" data-t="02:50:00">[02:50:00]</a>. The [[Graph data structures in AI and its benefits | graph-powered AI for uncovering fraud networks]] is structured in layers, allowing agents to efficiently query specific data for tasks like impact assessment, test plan creation, and execution <a class="yt-timestamp" data-t="02:53:53">[02:53:53]</a>. Fine-tuning query agents on schema information and example queries reduced token consumption and response time <a class="yt-timestamp" data-t="02:57:10">[02:57:10]</a>.
*   **Yhar.ai for Legal Documents:** Yhar.ai converts legal documents into graphs to identify class action cases. They use multi-agent systems and graphs to break down complex legal workflows into testable steps, controlling state through the graph <a class="yt-timestamp" data-t="03:06:08">[03:06:08]</a> <a class="yt-timestamp" data-t="03:09:49">[03:09:49]</a>. This ensures necessary accuracy and supports creative legal arguments by structuring information and pruning state over time <a class="yt-timestamp" data-t="03:10:40">[03:10:40]</a> <a class="yt-timestamp" data-t="03:11:23">[03:11:23]</a>. This also aids in legal discovery by structuring vast amounts of unstructured data (e.g., emails) into a graph, enabling targeted information retrieval and visualization <a class="yt-timestamp" data-t="03:15:31">[03:15:31]</a>. For case research, they scrape and filter web data to qualify leads, applying specific schemas to personalize information for lawyers <a class="yt-timestamp" data-t="03:18:29">[03:18:29]</a>. This process of [[Semantic enrichment and graphbased searches in architecture | semantic enrichment and graph-based searches in architecture]] allows them to find potential lawsuits significantly earlier than traditional methods <a class="yt-timestamp" data-t="03:21:48">[03:21:48]</a>.

### Other Notable Patterns and Tools
*   **Graph Construction Patterns:** These include lexical graphs (representing document chunks and relationships) and domain graphs (entities and their relationships) <a class="yt-timestamp" data-t="03:19:00">[03:19:00]</a>.
*   **Enrichment with Graph Algorithms:** Algorithms like clustering, link prediction, and PageRank can enrich the graph, identifying cross-document topics and communities <a class="yt-timestamp" data-t="03:26:39">[03:26:39]</a> <a class="yt-timestamp" data-t="03:39:00">[03:39:00]</a>.
*   **Graph Retrieval:** Involves an initial index search (vector, full-text, hybrid, spatial) to find entry points, followed by relationship traversal to fetch additional context <a class="yt-timestamp" data-t="03:27:21">[03:27:21]</a>. Modern LLMs are increasingly trained to process graph structures, allowing richer context to be passed to them <a class="yt-timestamp" data-t="03:38:33">[03:38:33]</a>.
*   **Agentic Approach:** Breaking down user questions into individual tasks, extracting parameters, and running specialized tools (Cypher queries) in sequence or loops <a class="yt-timestamp" data-t="02:10:00">[02:10:00]</a> <a class="yt-timestamp" data-t="02:41:41">[02:41:41]</a>.
*   **Agentic Firewall:** A conceptual use case where a human-language shell with episodic and temporal memory of user actions across machines and sessions could provide enhanced security context <a class="yt-timestamp" data-t="02:02:13">[02:02:13]</a>. This directly relates to [[handling_complex_queries_with_deep_research | handling complex queries with deep research]].

# Conclusion

Graph databases, especially when combined with LLMs in [[GraphRAG systems and applications | GraphRAG systems]] and advanced agent memory frameworks, represent a powerful paradigm shift in AI applications. They enable detailed relational and temporal reasoning, offer significant improvements in accuracy and explainability, and are being successfully adopted in diverse industries, from finance and legal to networking and customer support. The emphasis on causality and interconnectedness makes graph databases a fundamental component for building more intelligent, robust, and reliable AI systems.