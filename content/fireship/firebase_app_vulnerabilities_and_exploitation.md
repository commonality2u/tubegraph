---
title: Firebase app vulnerabilities and exploitation
videoId: b7PUm7LmAOw
---

From: [[fireship]] <br/> 

Unsecured [[introduction_to_firebase_and_benefits|Firebase]] applications can be highly vulnerable to data theft and deletion <a class="yt-timestamp" data-t="00:00:06">[00:00:06]</a>. If backend security rules are not properly configured, an attacker can steal and delete all your data <a class="yt-timestamp" data-t="00:00:08">[00:00:08]</a>.

## Exploiting Unsecured Firebase Apps

An attacker can exploit a [[introduction_to_firebase_and_benefits|Firebase]] app by:
1.  Accessing the Chrome developer tools and the network tab <a class="yt-timestamp" data-t="00:00:14">[00:00:14]</a>.
2.  Finding a request originating from [[introduction_to_firebase_and_benefits|Firebase]] <a class="yt-timestamp" data-t="00:00:16">[00:00:16]</a>.
3.  Opening the request headers to locate the corresponding project ID <a class="yt-timestamp" data-t="00:00:20">[00:00:20]</a>.
4.  Using the command line to execute a `curl delete` request to the [[introduction_to_firebase_and_benefits|Firebase]] REST API, which can then wipe out the app's database <a class="yt-timestamp" data-t="00:00:27">[00:00:27]</a>.

> [!CAUTION]
> If a [[introduction_to_firebase_and_benefits|Firebase]] app is deployed without backend rules, anyone can perform these actions to delete or steal data <a class="yt-timestamp" data-t="00:00:32">[00:00:32]</a>. This highlights a significant [[common_web_application_security_risks|security risk]] for web applications.

## Securing Your Firestore Database with Security Rules

To prevent such vulnerabilities, it is crucial to write expressive and understandable backend security rules for your [[introduction_to_firebase_and_benefits|Firestore]] database <a class="yt-timestamp" data-t="00:00:39">[00:00:39]</a>.

### Accessing and Defining Rules

Security rules are defined in their own specialized language within the [[introduction_to_firebase_and_benefits|Firestore]] database's "rules" tab <a class="yt-timestamp" data-t="00:00:53">[00:00:53]</a>. All rule logic is defined within a root block <a class="yt-timestamp" data-t="00:01:01">[00:01:01]</a>.

### Rule Structure

Rules use the `match` keyword to specify database paths where rules will be applied <a class="yt-timestamp" data-t="00:01:06">[00:01:06]</a>. The `allow` keyword follows, specifying the operation for which a rule is set <a class="yt-timestamp" data-t="00:01:16">[00:01:16]</a>. An expression that returns true or false can be written to apply specific logic <a class="yt-timestamp" data-t="00:01:24">[00:01:24]</a>.

For example, to completely lock down all documents, one could use `allow read, write: if false;` <a class="yt-timestamp" data-t="00:01:31">[00:01:31]</a>. This would prevent client-side reads or writes, resulting in errors if the front-end app attempts to query data <a class="yt-timestamp" data-t="00:01:39">[00:01:39]</a>.

### Rule Types and Operations

Rules can be scoped to specific operations:
*   **Read Rules**
    *   `get`: Applies to reading a specific document <a class="yt-timestamp" data-t="00:01:59">[00:01:59]</a>.
    *   `list`: Applies to a collection query <a class="yt-timestamp" data-t="00:02:02">[00:02:02]</a>.
    *   `read`: Combines `get` and `list` operations <a class="yt-timestamp" data-t="00:02:17">[00:02:17]</a>.
*   **Write Rules**
    *   `create`: Applies to creating new data <a class="yt-timestamp" data-t="00:02:09">[00:02:09]</a>.
    *   `update`: Applies to modifying existing data <a class="yt-timestamp" data-t="00:02:11">[00:02:11]</a>.
    *   `delete`: Applies to removing data <a class="yt-timestamp" data-t="00:02:13">[00:02:13]</a>.
    *   `write`: Combines `create`, `update`, and `delete` into a single rule <a class="yt-timestamp" data-t="00:02:22">[00:02:22]</a>.

### Targeting Data Paths

*   `**` (double star): This special syntax tells rules to cascade down to all sub-collections and anything nested under that path <a class="yt-timestamp" data-t="00:02:43">[00:02:43]</a>. It's useful for rules that apply to many different collections, such as verifying [[user_authentication_with_firebase|user authentication]] <a class="yt-timestamp" data-t="00:02:48">[00:02:48]</a>.
*   **Specific Document ID**: Rules can point to a specific document by hard-coding its ID directly into the path <a class="yt-timestamp" data-t="00:02:59">[00:02:59]</a>.
*   **Wildcard ID**: The most useful matcher, indicated by `[variableName]` in brackets. This allows the ID to be evaluated as a variable at runtime <a class="yt-timestamp" data-t="00:03:11">[00:03:11]</a>.

> [!TIP]
> [[introduction_to_firebase_and_benefits|Firestore]] rules are secure by default <a class="yt-timestamp" data-t="00:03:34">[00:03:34]</a>. Unless an operation is explicitly allowed, it will be blocked <a class="yt-timestamp" data-t="00:03:37">[00:03:37]</a>.

### The Request Object

The `request` object is built into the rules environment and is vital for providing information about the current user and incoming requests <a class="yt-timestamp" data-t="00:03:52">[00:03:52]</a>. For instance, `request.auth != null` checks if a user is logged in <a class="yt-timestamp" data-t="00:03:58">[00:03:58]</a>.

### Custom Functions for Readability

Custom functions can be written to make rules more DRY (Don't Repeat Yourself) and readable <a class="yt-timestamp" data-t="00:04:14">[00:04:14]</a>. For example, an `isSigned` function can encapsulate `request.auth != null`, making rules like `allow delete: if isSigned();` easily understandable <a class="yt-timestamp" data-t="00:04:33">[00:04:33]</a>.

### Advanced Rule Logic

*   **Determining Ownership**: Rules can determine if a user is the owner of a document <a class="yt-timestamp" data-t="00:04:47">[00:04:47]</a>. For example, allowing reads of user profiles by anyone signed in, but only allowing writes by the profile owner <a class="yt-timestamp" data-t="00:05:04">[00:05:04]</a>. This requires the document ID to match the [[user_authentication_with_firebase|user ID]] <a class="yt-timestamp" data-t="00:05:13">[00:05:13]</a>. The function would compare `request.auth.uid` to the `user ID` on the document <a class="yt-timestamp" data-t="00:05:27">[00:05:27]</a>.
*   **Chaining Conditions**:
    *   `and`: Both functions or conditions must return true for the rule to pass <a class="yt-timestamp" data-t="00:05:51">[00:05:51]</a>.
    *   `or`: Only one of the conditions needs to be true <a class="yt-timestamp" data-t="00:05:55">[00:05:55]</a>.
*   **User Information from `request.auth.token`**: The `request.auth.token` object contains useful information like `email_verified`, `sign_in_time`, `anonymous`, or `phone_number`, which can be used to compose rules <a class="yt-timestamp" data-t="00:06:17">[00:06:17]</a>.

### Comparing Existing and Incoming Data

*   **Existing Data (`resource.data`)**: Represents the state of the document *before* the request <a class="yt-timestamp" data-t="00:06:29">[00:06:29]</a>. Useful when users control whether a document can be modified after a certain state (e.g., locking a document after it's published) <a class="yt-timestamp" data-t="00:07:07">[00:07:07]</a>.
*   **Incoming Data (`request.resource.data`)**: Represents the data as it would exist *after* the request <a class="yt-timestamp" data-t="00:06:34">[00:06:34]</a>. Essential for applying validation rules to maintain database integrity (e.g., ensuring a product price is greater than $10) <a class="yt-timestamp" data-t="00:07:32">[00:07:32]</a>.

> [!NOTE]
> It's recommended to encapsulate `resource.data` and `request.resource.data` into custom functions like `existingData` and `incomingData` to avoid confusion <a class="yt-timestamp" data-t="00:06:39">[00:06:39]</a>.

### Rule-Based User Authorization (Reading Other Documents)

For scenarios like role-based authorization where user roles are stored in their user documents, the rules environment provides the `get` keyword <a class="yt-timestamp" data-t="00:08:00">[00:08:00]</a>.
*   `get('/users/$(request.auth.uid)')`: This reads the current user's document by interpolating the `request.auth.uid` into an absolute path <a class="yt-timestamp" data-t="00:08:18">[00:08:18]</a>.
*   After reading the user document, roles can be checked using methods like `.keys().hasAny(['editor', 'admin'])` to see if the user possesses any of the specified roles, or `.hasAll()` to check for all specified roles <a class="yt-timestamp" data-t="00:08:46">[00:08:46]</a>. This provides a simple solution for implementing rule-based [[user_authentication_with_firebase|user authorization]] <a class="yt-timestamp" data-t="00:08:52">[00:08:52]</a>.

### Time-Based Rules

Time can also impact database security, particularly for throttling data creation <a class="yt-timestamp" data-t="00:08:58">[00:08:58]</a>.
*   `request.time`: Provides the current timestamp of any request <a class="yt-timestamp" data-t="00:09:07">[00:09:07]</a>.
*   `duration`: A helper function that allows operations on timestamps, such as adding seconds, minutes, or hours <a class="yt-timestamp" data-t="00:09:27">[00:09:27]</a>. For example, a rule can ensure a user can only write to a product document every 60 seconds by comparing `request.time` to `created_at` plus a `duration` of 60 seconds <a class="yt-timestamp" data-t="00:09:23">[00:09:23]</a>.

By implementing these security rules, developers can prevent becoming the victim of a major data breach <a class="yt-timestamp" data-t="00:09:36">[00:09:36]</a>.