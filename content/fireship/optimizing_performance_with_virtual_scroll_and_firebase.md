---
title: Optimizing performance with virtual scroll and Firebase
videoId: Ppl64MY6FFc
---

From: [[fireship]] <br/> 

[[angular_7_virtual_scroll_feature_in_the_component_development_kit | Angular 7]] introduced the [[angular_7_virtual_scroll_feature_in_the_component_development_kit | virtual scroll]] feature within its Component Development Kit (CDK), enabling the creation of high-performance lists <a class="yt-timestamp" data-t="00:00:10">[00:00:10]</a>. This feature significantly improves application performance by only rendering the items visible to the user in the viewport, rather than rendering the entire list <a class="yt-timestamp" data-t="00:00:14">[00:00:14]</a> <a class="yt-timestamp" data-t="00:00:16">[00:00:16]</a> <a class="yt-timestamp" data-t="00:00:42">[00:00:42]</a> <a class="yt-timestamp" data-t="00:00:44">[00:00:44]</a>. This approach ensures much smoother performance when dealing with large datasets, as the browser only needs to render a small subset of the total data <a class="yt-timestamp" data-t="00:00:45">[00:00:45]</a> <a class="yt-timestamp" data-t="00:00:48">[00:00:48]</a>.

## [[setting_up_virtual_scroll_in_an_angular_app | Setting Up Virtual Scroll in an Angular App]]

To begin [[setting_up_virtual_scroll_in_an_angular_app | setting up virtual scroll]] in an Angular application, first ensure you are using Angular version 7 or higher <a class="yt-timestamp" data-t="00:01:08">[00:01:08]</a> <a class="yt-timestamp" data-t="00:01:09">[00:01:09]</a>.

### Installation

1.  **Add Angular Material/CDK**: The CDK can be added to your app by running `ng add angular material` <a class="yt-timestamp" data-t="00:01:12">[00:01:12]</a> <a class="yt-timestamp" data-t="00:01:14">[00:01:14]</a>. Angular 7 will provide prompts for configuration, for which default selections are usually sufficient <a class="yt-timestamp" data-t="00:01:16">[00:01:16]</a> <a class="yt-timestamp" data-t="00:01:18">[00:01:18]</a> <a class="yt-timestamp" data-t="00:01:19">[00:01:19]</a>.
2.  **Install AngularFire (Optional)**: If you plan to implement the Firebase-backed real-time features, install AngularFire as well <a class="yt-timestamp" data-t="00:01:23">[00:01:23]</a> <a class="yt-timestamp" data-t="00:01:24">[00:01:24]</a> <a class="yt-timestamp" data-t="00:01:25">[00:01:25]</a>.
3.  **Import `ScrollingModule`**: In your `app.module.ts`, import `ScrollingModule` from `@angular/cdk/scrolling` and include it in your imports array <a class="yt-timestamp" data-t="00:01:33">[00:01:33]</a> <a class="yt-timestamp" data-t="00:01:34">[00:01:34]</a> <a class="yt-timestamp" data-t="00:01:35">[00:01:35]</a> <a class="yt-timestamp" data-t="00:01:41">[00:01:41]</a> <a class="yt-timestamp" data-t="00:01:42">[00:01:42]</a>.

### Basic Implementation

1.  **Data Generation**: To test virtual scrolling, generate a large list of fake data. This can be done using a library like Faker.js to create fake names, bios, and other details <a class="yt-timestamp" data-t="00:01:53">[00:01:53]</a> <a class="yt-timestamp" data-t="00:01:54">[00:01:54]</a> <a class="yt-timestamp" data-t="00:01:55">[00:01:55]</a> <a class="yt-timestamp" data-t="00:02:00">[00:02:00]</a> <a class="yt-timestamp" data-t="00:02:01">[00:02:01]</a>.
2.  **Viewport Component**: In your HTML, use the `<cdk-virtual-scroll-viewport>` component. This component requires an `itemSize` input, which represents the height of each item in pixels <a class="yt-timestamp" data-t="00:02:26">[00:02:26]</a> <a class="yt-timestamp" data-t="00:02:27">[00:02:27]</a> <a class="yt-timestamp" data-t="00:02:28">[00:02:28]</a> <a class="yt-timestamp" data-t="00:02:31">[00:02:31]</a> <a class="yt-timestamp" data-t="00:02:32">[00:02:32]</a> <a class="yt-timestamp" data-t="00:02:33">[00:02:33]</a>. For optimal performance, items should have a fixed height <a class="yt-timestamp" data-t="00:02:37">[00:02:37]</a> <a class="yt-timestamp" data-t="00:02:38">[00:02:38]</a>.
3.  **CSS Styling**: Ensure the viewport has a defined height (e.g., `height: 100vh`) and that each list item has a fixed height that matches the `itemSize` value (e.g., `height: 100px`) <a class="yt-timestamp" data-t="00:02:44">[00:02:44]</a> <a class="yt-timestamp" data-t="00:02:45">[00:02:45]</a> <a class="yt-timestamp" data-t="00:02:46">[00:02:46]</a> <a class="yt-timestamp" data-t="00:02:51">[00:02:51]</a> <a class="yt-timestamp" data-t="00:02:52">[00:02:52]</a> <a class="yt-timestamp" data-t="00:02:53">[00:02:53]</a>.
4.  **`cdkVirtualFor` Directive**: Inside the `cdk-virtual-scroll-viewport`, use the `cdkVirtualFor` structural directive, which functions similarly to `ngFor` <a class="yt-timestamp" data-t="00:03:10">[00:03:10]</a> <a class="yt-timestamp" data-t="00:03:11">[00:03:11]</a> <a class="yt-timestamp" data-t="00:03:12">[00:03:12]</a> <a class="yt-timestamp" data-t="00:03:13">[00:03:13]</a> <a class="yt-timestamp" data-t="00:03:14">[00:03:14]</a>.

    *   When the app is served, the CDK dynamically manages which items are rendered based on visibility <a class="yt-timestamp" data-t="00:03:18">[00:03:18]</a> <a class="yt-timestamp" data-t="00:03:19">[00:03:19]</a> <a class="yt-timestamp" data-t="00:03:20">[00:03:20]</a>.
    *   A unique side effect is that CSS animations will be reapplied each time an item is re-rendered in the DOM, unlike a regular list where animations only apply on initial page load <a class="yt-timestamp" data-t="00:03:26">[00:03:26]</a> <a class="yt-timestamp" data-t="00:03:27">[00:03:27]</a> <a class="yt-timestamp" data-t="00:03:28">[00:03:28]</a> <a class="yt-timestamp" data-t="00:03:29">[00:03:29]</a> <a class="yt-timestamp" data-t="00:03:30">[00:03:30]</a> <a class="yt-timestamp" data-t="00:03:31">[00:03:31]</a> <a class="yt-timestamp" data-t="00:03:40">[00:03:40]</a> <a class="yt-timestamp" data-t="00:03:41">[00:03:41]</a> <a class="yt-timestamp" data-t="00:03:42">[00:03:42]</a>.

### Virtual Scroll API

The `cdk-virtual-scroll-viewport` component emits a `scrolledIndexChange` event, which provides the index of the item the user has scrolled to <a class="yt-timestamp" data-t="00:03:55">[00:03:55]</a> <a class="yt-timestamp" data-t="00:03:56">[00:03:56]</a> <a class="yt-timestamp" data-t="00:03:57">[00:03:57]</a> <a class="yt-timestamp" data-t="00:03:58">[00:03:58]</a> <a class="yt-timestamp" data-t="00:04:04">[00:04:04]</a> <a class="yt-timestamp" data-t="00:04:05">[00:04:05]</a>. This event is crucial for implementing infinite scroll by determining when to fetch the next batch of items <a class="yt-timestamp" data-t="00:04:00">[00:04:00]</a> <a class="yt-timestamp" data-t="00:04:01">[00:04:01]</a> <a class="yt-timestamp" data-t="00:04:07">[00:04:07]</a> <a class="yt-timestamp" data-t="00:04:08">[00:04:08]</a>.

Additionally, the component exposes a public API that allows dynamic interaction, such as:
*   Measuring the viewport <a class="yt-timestamp" data-t="00:04:14">[00:04:14]</a>.
*   Getting the total item list size <a class="yt-timestamp" data-t="00:04:15">[00:04:15]</a>.
*   Dynamically scrolling to a specific element <a class="yt-timestamp" data-t="00:04:17">[00:04:17]</a> <a class="yt-timestamp" data-t="00:04:18">[00:04:18]</a>.

To access these methods, you can use `@ViewChild` to grab the component from the DOM and strongly type it as `CdkVirtualScrollViewport` <a class="yt-timestamp" data-t="00:04:22">[00:04:22]</a> <a class="yt-timestamp" data-t="00:04:23">[00:04:23]</a> <a class="yt-timestamp" data-t="00:04:24">[00:04:24]</a> <a class="yt-timestamp" data-t="00:04:25">[00:04:25]</a> <a class="yt-timestamp" data-t="00:04:26">[00:04:26]</a> <a class="yt-timestamp" data-t="00:04:27">[00:04:27]</a> <a class="yt-timestamp" data-t="00:04:28">[00:04:28]</a>.

## [[Implementing realtime infinite scroll with Firebase Firestore | Implementing Real-time Infinite Scroll with Firebase Firestore]]

Combining [[setting_up_virtual_scroll_in_an_angular_app | virtual scroll]] with [[working_with_firebase_firestore_and_realtime_updates | Firebase Firestore]] allows for a highly performant and real-time infinite scrolling experience <a class="yt-timestamp" data-t="00:04:53">[00:04:53]</a> <a class="yt-timestamp" data-t="00:04:54">[00:04:54]</a> <a class="yt-timestamp" data-t="00:04:55">[00:04:55]</a>. This improved solution provides real-time updates to data even when items are pulled in batches, and offers significantly better performance due to virtual scrolling <a class="yt-timestamp" data-t="00:05:03">[00:05:03]</a> <a class="yt-timestamp" data-t="00:05:04">[00:05:04]</a> <a class="yt-timestamp" data-t="00:05:05">[00:05:05]</a> <a class="yt-timestamp" data-t="00:05:06">[00:05:06]</a> <a class="yt-timestamp" data-t="00:05:07">[00:05:07]</a> <a class="yt-timestamp" data-t="00:05:08">[00:05:08]</a> <a class="yt-timestamp" data-t="00:05:13">[00:05:13]</a> <a class="yt-timestamp" data-t="00:05:14">[00:05:14]</a> <a class="yt-timestamp" data-t="00:05:15">[00:05:15]</a>.

### Component Logic

1.  **Imports**: Import `AngularFirestore` and necessary RxJS operators (e.g., `BehaviorSubject`, `throttleTime`, `mergeMap`, `scan`) <a class="yt-timestamp" data-t="00:05:26">[00:05:26]</a> <a class="yt-timestamp" data-t="00:05:27">[00:05:27]</a> <a class="yt-timestamp" data-t="00:05:28">[00:05:28]</a> <a class="yt-timestamp" data-t="00:05:29">[00:05:29]</a>.
2.  **State Variables**:
    *   Define `batchSize` (e.g., 20 items) <a class="yt-timestamp" data-t="00:05:31">[00:05:31]</a>.
    *   A property for the viewport (`@ViewChild`) <a class="yt-timestamp" data-t="00:05:35">[00:05:35]</a> <a class="yt-timestamp" data-t="00:05:36">[00:05:36]</a>.
    *   A boolean `theEnd` to indicate if all data has been fetched <a class="yt-timestamp" data-t="00:05:37">[00:05:37]</a> <a class="yt-timestamp" data-t="00:05:38">[00:05:38]</a> <a class="yt-timestamp" data-t="00:05:39">[00:05:39]</a>.
    *   A `BehaviorSubject` to track the `offset` for Firestore queries, initialized to `null` <a class="yt-timestamp" data-t="00:05:41">[00:05:41]</a> <a class="yt-timestamp" data-t="00:05:42">[00:05:42]</a> <a class="yt-timestamp" data-t="00:05:43">[00:05:43]</a> <a class="yt-timestamp" data-t="00:05:44">[00:05:44]</a> <a class="yt-timestamp" data-t="00:05:48">[00:05:48]</a>.
3.  **`nextBatch` Method**: This method is called by the `scrolledIndexChange` event.
    *   It checks if the end of the list has been reached (`theEnd`).
    *   It compares the `viewport.renderedRange.end` (index of the last rendered item) with `viewport.getDataLength()` (total items in the array) to determine if the user has scrolled to the end of the current loaded data <a class="yt-timestamp" data-t="00:06:19">[00:06:19]</a> <a class="yt-timestamp" data-t="00:06:20">[00:06:20]</a> <a class="yt-timestamp" data-t="00:06:21">[00:06:21]</a> <a class="yt-timestamp" data-t="00:06:22">[00:06:22]</a> <a class="yt-timestamp" data-t="00:06:23">[00:06:23]</a> <a class="yt-timestamp" data-t="00:06:24">[00:06:24]</a> <a class="yt-timestamp" data-t="00:06:27">[00:06:27]</a> <a class="yt-timestamp" data-t="00:06:28">[00:06:28]</a> <a class="yt-timestamp" data-t="00:06:29">[00:06:29]</a>.
    *   If the end is reached, it sends the next offset value (the last item's identifier) to the `BehaviorSubject`, triggering a new Firestore query <a class="yt-timestamp" data-t="00:06:36">[00:06:36]</a> <a class="yt-timestamp" data-t="00:06:37">[00:06:37]</a> <a class="yt-timestamp" data-t="00:06:38">[00:06:38]</a>.
4.  **`trackBy` Function**: A `trackBy` function (e.g., tracking the index of items) is used to ensure that only changed items are re-rendered for real-time data, preventing the entire list from re-rendering on every change <a class="yt-timestamp" data-t="00:06:44">[00:06:44]</a> <a class="yt-timestamp" data-t="00:06:45">[00:06:45]</a> <a class="yt-timestamp" data-t="00:06:46">[00:06:46]</a> <a class="yt-timestamp" data-t="00:06:47">[00:06:47]</a> <a class="yt-timestamp" data-t="00:06:48">[00:06:48]</a> <a class="yt-timestamp" data-t="00:06:49">[00:06:49]</a> <a class="yt-timestamp" data-t="00:06:50">[00:06:50]</a>.
5.  **Firestore Batch Query**:
    *   To get an individual batch, a Firestore query is constructed, ordering by a specific field (e.g., 'name') and starting *after* the `offset` value <a class="yt-timestamp" data-t="00:07:04">[00:07:04]</a> <a class="yt-timestamp" data-t="00:07:05">[00:07:05]</a> <a class="yt-timestamp" data-t="00:07:06">[00:07:06]</a> <a class="yt-timestamp" data-t="00:07:07">[00:07:07]</a> <a class="yt-timestamp" data-t="00:07:13">[00:07:13]</a> <a class="yt-timestamp" data-t="00:07:14">[00:07:14]</a> <a class="yt-timestamp" data-t="00:07:16">[00:07:16]</a> <a class="yt-timestamp" data-t="00:07:17">[00:07:17]</a> <a class="yt-timestamp" data-t="00:07:18">[00:07:18]</a>.
    *   The query uses `limit` to specify the `batchSize` <a class="yt-timestamp" data-t="00:07:29">[00:07:29]</a>.
    *   `snapshotChanges()` is used to get document snapshots as an observable <a class="yt-timestamp" data-t="00:07:34">[00:07:34]</a> <a class="yt-timestamp" data-t="00:07:35">[00:07:35]</a> <a class="yt-timestamp" data-t="00:07:36">[00:07:36]</a>.
    *   If an empty array is emitted, `theEnd` is set to `true`, indicating the end of the collection <a class="yt-timestamp" data-t="00:07:39">[00:07:39]</a> <a class="yt-timestamp" data-t="00:07:40">[00:07:40]</a> <a class="yt-timestamp" data-t="00:07:41">[00:07:41]</a>.
    *   Documents are mapped to an object where the key is their document ID. This allows for reliable real-time updates anywhere in the list based on the document's key, rather than its index position, preventing duplicate documents <a class="yt-timestamp" data-t="00:07:53">[00:07:53]</a> <a class="yt-timestamp" data-t="00:07:54">[00:07:54]</a> <a class="yt-timestamp" data-t="00:07:55">[00:07:55]</a> <a class="yt-timestamp" data-t="00:07:56">[00:07:56]</a> <a class="yt-timestamp" data-t="00:07:57">[00:07:57]</a> <a class="yt-timestamp" data-t="00:07:58">[00:07:58]</a> <a class="yt-timestamp" data-t="00:07:59">[00:07:59]</a> <a class="yt-timestamp" data-t="00:08:00">[00:08:00]</a> <a class="yt-timestamp" data-t="00:08:01">[00:08:01]</a> <a class="yt-timestamp" data-t="00:08:02">[00:08:02]</a> <a class="yt-timestamp" data-t="00:08:03">[00:08:03]</a> <a class="yt-timestamp" data-t="00:08:04">[00:08:04]</a> <a class="yt-timestamp" data-t="00:08:05">[00:08:05]</a> <a class="yt-timestamp" data-t="00:08:06">[00:08:06]</a> <a class="yt-timestamp" data-t="00:08:07">[00:08:07]</a> <a class="yt-timestamp" data-t="00:08:08">[00:08:08]</a>.
6.  **Combining Batches with RxJS**:
    *   A source observable is set up in the constructor to listen to the `offset` value <a class="yt-timestamp" data-t="00:08:16">[00:08:16]</a> <a class="yt-timestamp" data-t="00:08:17">[00:08:17]</a> <a class="yt-timestamp" data-t="00:08:18">[00:08:18]</a> <a class="yt-timestamp" data-t="00:08:19">[00:08:19]</a> <a class="yt-timestamp" data-t="00:08:20">[00:08:20]</a> <a class="yt-timestamp" data-t="00:08:21">[00:08:21]</a>.
    *   It uses `mergeMap` to merge new batches into the stream whenever the offset changes <a class="yt-timestamp" data-t="00:08:22">[00:08:22]</a> <a class="yt-timestamp" data-t="00:08:23">[00:08:23]</a> <a class="yt-timestamp" data-t="00:08:24">[00:08:24]</a>. `mergeMap` is crucial here because `switchMap` would cancel previous subscriptions, making only the latest batch real-time <a class="yt-timestamp" data-t="00:08:40">[00:08:40]</a> <a class="yt-timestamp" data-t="00:08:41">[00:08:41]</a> <a class="yt-timestamp" data-t="00:08:42">[00:08:42]</a> <a class="yt-timestamp" data-t="00:08:43">[00:08:43]</a> <a class="yt-timestamp" data-t="00:08:44">[00:08:44]</a> <a class="yt-timestamp" data-t="00:08:45">[00:08:45]</a> <a class="yt-timestamp" data-t="00:08:46">[00:08:46]</a> <a class="yt-timestamp" data-t="00:08:47">[00:08:47]</a> <a class="yt-timestamp" data-t="00:08:48">[00:08:48]</a> <a class="yt-timestamp" data-t="00:08:49">[00:08:49]</a> <a class="yt-timestamp" data-t="00:08:50">[00:08:50]</a>.
    *   `throttleTime` (e.g., 500ms) is used to prevent redundant backend requests when the scroll event fires multiple times <a class="yt-timestamp" data-t="00:08:31">[00:08:31]</a> <a class="yt-timestamp" data-t="00:08:32">[00:08:32]</a> <a class="yt-timestamp" data-t="00:08:33">[00:08:33]</a> <a class="yt-timestamp" data-t="00:08:34">[00:08:34]</a> <a class="yt-timestamp" data-t="00:08:35">[00:08:35]</a> <a class="yt-timestamp" data-t="00:08:36">[00:08:36]</a> <a class="yt-timestamp" data-t="00:08:37">[00:08:37]</a>.
    *   The `scan` operator merges the current batch with existing batches, maintaining a single source of truth for all mapped items <a class="yt-timestamp" data-t="00:08:52">[00:08:52]</a> <a class="yt-timestamp" data-t="00:08:53">[00:08:53]</a> <a class="yt-timestamp" data-t="00:08:54">[00:08:54]</a> <a class="yt-timestamp" data-t="00:08:55">[00:08:55]</a> <a class="yt-timestamp" data-t="00:08:56">[00:08:56]</a> <a class="yt-timestamp" data-t="00:08:57">[00:08:57]</a> <a class="yt-timestamp" data-t="00:08:58">[00:08:58]</a> <a class="yt-timestamp" data-t="00:08:59">[00:08:59]</a>.
    *   Finally, the combined `batchMap` observable is mapped to an array of objects for looping in the front end using `Object.values()` <a class="yt-timestamp" data-t="00:09:05">[00:09:05]</a> <a class="yt-timestamp" data-t="00:09:06">[00:09:06]</a> <a class="yt-timestamp" data-t="00:09:07">[00:09:07]</a> <a class="yt-timestamp" data-t="00:09:10">[00:09:10]</a> <a class="yt-timestamp" data-t="00:09:11">[00:09:11]</a> <a class="yt-timestamp" data-t="00:09:12">[00:09:12]</a> <a class="yt-timestamp" data-t="00:09:14">[00:09:14]</a> <a class="yt-timestamp" data-t="00:09:15">[00:09:15]</a> <a class="yt-timestamp" data-t="00:09:16">[00:09:16]</a>.

### HTML Modifications

1.  **Index and TrackBy**: Use `let i = index` to show the item's index and apply the `trackBy` function to `cdkVirtualFor` <a class="yt-timestamp" data-t="00:09:33">[00:09:33]</a> <a class="yt-timestamp" data-t="00:09:34">[00:09:34]</a> <a class="yt-timestamp" data-t="00:09:35">[00:09:35]</a> <a class="yt-timestamp" data-t="00:09:36">[00:09:36]</a> <a class="yt-timestamp" data-t="00:09:37">[00:09:37]</a>.
2.  **`scrolledIndexChange` Event**: Listen to the `scrolledIndexChange` event and pass the event (index number) and the last item's name (for the offset) to the `nextBatch` method <a class="yt-timestamp" data-t="00:09:40">[00:09:40]</a> <a class="yt-timestamp" data-t="00:09:41">[00:09:41]</a> <a class="yt-timestamp" data-t="00:09:42">[00:09:42]</a> <a class="yt-timestamp" data-t="00:09:43">[00:09:43]</a> <a class="yt-timestamp" data-t="00:09:44">[00:09:44]</a> <a class="yt-timestamp" data-t="00:09:45">[00:09:45]</a> <a class="yt-timestamp" data-t="00:09:47">[00:09:47]</a> <a class="yt-timestamp" data-t="00:09:48">[00:09:48]</a> <a class="yt-timestamp" data-t="00:09:49">[00:09:49]</a> <a class="yt-timestamp" data-t="00:09:50">[00:09:50]</a>.
3.  **Unwrap Observable**: Use an `ng-container` with the `async` pipe to unwrap the infinite observable and assign it to a template variable (e.g., `as people`) for iteration <a class="yt-timestamp" data-t="00:10:01">[00:10:01]</a> <a class="yt-timestamp" data-t="00:10:02">[00:10:02]</a> <a class="yt-timestamp" data-t="00:10:03">[00:10:03]</a> <a class="yt-timestamp" data-t="00:10:04">[00:10:04]</a> <a class="yt-timestamp" data-t="00:10:05">[00:10:05]</a> <a class="yt-timestamp" data-t="00:10:06">[00:10:06]</a> <a class="yt-timestamp" data-t="00:10:07">[00:10:07]</a> <a class="yt-timestamp" data-t="00:10:09">[00:10:09]</a> <a class="yt-timestamp" data-t="00:10:10">[00:10:10]</a> <a class="yt-timestamp" data-t="00:10:11">[00:10:11]</a> <a class="yt-timestamp" data-t="00:10:12">[00:10:12]</a> <a class="yt-timestamp" data-t="00:10:13">[00:10:13]</a> <a class="yt-timestamp" data-t="00:10:14">[00:10:14]</a>.

The result is a seemingly endless list that instantly reflects data changes in Firestore. Although the position of an item won't change if its data is updated, and deleted items won't be removed, the real-time updates for displayed information are instantaneous <a class="yt-timestamp" data-t="00:10:27">[00:10:27]</a> <a class="yt-timestamp" data-t="00:10:28">[00:10:28]</a> <a class="yt-timestamp" data-t="00:10:29">[00:10:29]</a> <a class="yt-timestamp" data-t="00:10:30">[00:10:30]</a> <a class="yt-timestamp" data-t="00:10:31">[00:10:31]</a> <a class="yt-timestamp" data-t="00:10:32">[00:10:32]</a> <a class="yt-timestamp" data-t="00:10:33">[00:10:33]</a> <a class="yt-timestamp" data-t="00:10:34">[00:10:34]</a> <a class="yt-timestamp" data-t="00:10:35">[00:10:35]</a> <a class="yt-timestamp" data-t="00:10:36">[00:10:36]</a> <a class="yt-timestamp" data-t="00:10:37">[00:10:37]</a>. The array of items grows in batches (e.g., 20, 40, 60 items) as the user scrolls, but from the user's perspective, the list appears to exist all along, providing a seamless [[Implementing realtime infinite scroll with Firebase Firestore | infinite scroll]] experience <a class="yt-timestamp" data-t="00:10:49">[00:10:49]</a> <a class="yt-timestamp" data-t="00:10:50">[00:10:50]</a> <a class="yt-timestamp" data-t="00:10:51">[00:10:51]</a> <a class="yt-timestamp" data-t="00:10:52">[00:10:52]</a> <a class="yt-timestamp" data-t="00:10:53">[00:10:53]</a> <a class="yt-timestamp" data-t="00:10:54">[00:10:54]</a> <a class="yt-timestamp" data-t="00:10:55">[00:10:55]</a> <a class="yt-timestamp" data-t="00:10:59">[00:10:59]</a> <a class="yt-timestamp" data-t="00:11:00">[00:11:00]</a> <a class="yt-timestamp" data-t="00:11:01">[00:11:01]</a> <a class="yt-timestamp" data-t="00:11:02">[00:11:02]</a> <a class="yt-timestamp" data-t="00:11:03">[00:11:03]</a> <a class="yt-timestamp" data-t="00:11:04">[00:11:04]</a>. Once the end of the data is reached, an indicator can be displayed to the user <a class="yt-timestamp" data-t="00:11:07">[00:11:07]</a> <a class="yt-timestamp" data-t="00:11:08">[00:11:08]</a> <a class="yt-timestamp" data-t="00:11:09">[00:11:09]</a> <a class="yt-timestamp" data-t="00:11:10">[00:11:10]</a> <a class="yt-timestamp" data-t="00:11:11">[00:11:11]</a> <a class="yt-timestamp" data-t="00:11:12">[00:11:12]</a> <a class="yt-timestamp" data-t="00:11:13">[00:11:13]</a>.