---
title: Differences and similarities among frameworks like React Angular and Vue
videoId: cuHDQhDhvPE
---

From: [[fireship]] <br/> 
Which [[javascript_frameworks_and_their_updates | JavaScript framework]] is the best is a common question among developers, whether new or experienced <a class="yt-timestamp" data-t="00:00:00">[00:00:00]</a>. While some metrics show different leaders – React leads in downloads <a class="yt-timestamp" data-t="00:00:02">[00:00:02]</a>, Vue in GitHub stars <a class="yt-timestamp" data-t="00:00:04">[00:00:04]</a>, and Svelte was the most loved in the 2021 Stack Overflow survey <a class="yt-timestamp" data-t="00:00:06">[00:00:06]</a> – there's no single "absolute best" framework <a class="yt-timestamp" data-t="00:00:23">[00:00:23]</a>. The optimal choice often depends on individual project needs and preferences, and the best way to determine satisfaction is to [[building_a_todo_app_with_different_javascript_frameworks | build something with all of them]] <a class="yt-timestamp" data-t="00:00:26">[00:00:26]</a>. This article explores the [[comparison_of_10_web_frameworks | tradeoffs of JavaScript frameworks]] by examining how they handle the same application <a class="yt-timestamp" data-t="00:00:40">[00:00:40]</a>.

## Why JavaScript Frameworks?
While some argue that a [[choosing_the_best_javascript_framework | JavaScript framework]] isn't necessary <a class="yt-timestamp" data-t="00:00:59">[00:00:59]</a>, attempting to build a non-trivial application with vanilla JavaScript can lead to complications, as one might end up creating their own inefficient framework <a class="yt-timestamp" data-t="00:01:06">[00:01:06]</a>. Frameworks address critical aspects of application development such as state management, data binding, events, and the application lifecycle <a class="yt-timestamp" data-t="00:01:41">[00:01:41]</a>. The primary feature frameworks offer that vanilla JavaScript lacks is an automatic way to bind HTML to JavaScript <a class="yt-timestamp" data-t="00:01:48">[00:01:48]</a>. In vanilla JavaScript, developers must imperatively select DOM elements and manually update the UI, making complex applications difficult to manage and synchronize data with the UI <a class="yt-timestamp" data-t="00:01:55">[00:01:55]</a>.

## Comparison of Frameworks

### Vanilla JavaScript
*   **Methodology**: Requires manual DOM manipulation using `document.querySelector` to grab elements and `document.createElement` to update the UI <a class="yt-timestamp" data-t="00:01:57">[00:01:57]</a>. State and UI are completely decoupled, making synchronization challenging <a class="yt-timestamp" data-t="00:03:03">[00:03:03]</a>. Event listeners must be explicitly registered <a class="yt-timestamp" data-t="00:03:15">[00:03:15]</a>.
*   **Limitations**: Code does not scale well for complexity <a class="yt-timestamp" data-t="00:04:09">[00:04:09]</a>. Features like routing or animation must be implemented from scratch <a class="yt-timestamp" data-t="00:04:13">[00:04:13]</a>. HTML markup does not convey bound events or data without inspecting the JavaScript code <a class="yt-timestamp" data-t="00:03:33">[00:03:33]</a>.

### React
*   **Popularity**: Most popular framework, with over 10 million weekly npm downloads and 170,000+ GitHub stars <a class="yt-timestamp" data-t="00:04:57">[00:04:57]</a>. Its popularity makes it a valuable skill for employment and collaboration <a class="yt-timestamp" data-t="00:05:04">[00:05:04]</a>.
*   **Philosophy**: Considered a library, it dictates a "React way" of development <a class="yt-timestamp" data-t="00:04:25">[00:04:25]</a>. Minimal by design, it relies on the open-source community for features like routing, animation, and state management <a class="yt-timestamp" data-t="00:04:41">[00:04:41]</a>. It is not opinionated about code organization, requiring developers to make decisions on libraries and maintainability <a class="yt-timestamp" data-t="00:04:48">[00:04:48]</a>.
*   **Project Setup**: Uses an official CLI, Create React App <a class="yt-timestamp" data-t="00:05:14">[00:05:14]</a>. Other tools like Next.js or Gatsby are also popular alternatives <a class="yt-timestamp" data-t="00:05:22">[00:05:22]</a>. Uses Webpack for code bundling <a class="yt-timestamp" data-t="00:05:37">[00:05:37]</a>.
*   **Core Concepts**: Applications are organized as a tree of declarative components <a class="yt-timestamp" data-t="00:05:44">[00:05:44]</a>. Components are often functional components that return JSX, an HTML-like syntax extended with JavaScript <a class="yt-timestamp" data-t="00:06:00">[00:06:00]</a>. Reactive state is managed with `useState` hooks, and lifecycle events with `useEffect` hooks <a class="yt-timestamp" data-t="00:06:20">[00:06:20]</a>. Events are bound directly in JSX (e.g., `onSubmit`) <a class="yt-timestamp" data-t="00:06:47">[00:06:47]</a>.
*   **Pros/Cons**: HTML is more descriptive <a class="yt-timestamp" data-t="00:07:10">[00:07:10]</a>. The `useEffect` hook can be confusing for beginners <a class="yt-timestamp" data-t="00:07:27">[00:07:27]</a>.

### Angular
*   **Popularity**: Developed and maintained by Google <a class="yt-timestamp" data-t="00:07:48">[00:07:48]</a>. It has 75,000 GitHub stars and is the second most downloaded framework on npm <a class="yt-timestamp" data-t="00:07:54">[00:07:54]</a>. Google uses it internally for hundreds of web apps <a class="yt-timestamp" data-t="00:08:14">[00:08:14]</a>.
*   **Philosophy**: Very opinionated about project organization and structure <a class="yt-timestamp" data-t="00:07:51">[00:07:51]</a>. Comes with officially supported libraries for routing, animation, and server-side rendering <a class="yt-timestamp" data-t="00:08:00">[00:08:00]</a>. Requires TypeScript <a class="yt-timestamp" data-t="00:08:12">[00:08:12]</a>.
*   **Project Setup**: Powerful CLI (`ng-new`, `ng generate component`) provides a large, pre-configured TypeScript project <a class="yt-timestamp" data-t="00:08:22">[00:08:22]</a>.
*   **Core Concepts**: Components are TypeScript classes with a `@Component` decorator <a class="yt-timestamp" data-t="00:08:41">[00:08:41]</a>. Components are typically broken into separate files for TypeScript, HTML, and CSS <a class="yt-timestamp" data-t="00:08:52">[00:08:52]</a>. Reactive state is defined as properties on the class <a class="yt-timestamp" data-t="00:09:00">[00:09:00]</a>. Lifecycle is managed by implementing methods like `ngOnInit` <a class="yt-timestamp" data-t="00:09:09">[00:09:09]</a>. Templates use a special templating language with directives like `ngFor` for looping <a class="yt-timestamp" data-t="00:09:20">[00:09:20]</a>. It brings JavaScript into HTML, opposite to React <a class="yt-timestamp" data-t="00:09:31">[00:09:31]</a>. Supports two-way data binding with `ngModel` <a class="yt-timestamp" data-t="00:09:44">[00:09:44]</a>, which requires importing the Angular forms module <a class="yt-timestamp" data-t="00:09:53">[00:09:53]</a>.
*   **Pros/Cons**: Higher learning curve <a class="yt-timestamp" data-t="00:10:03">[00:10:03]</a>. Predictable structure and excellent tooling for large teams and enterprise applications <a class="yt-timestamp" data-t="00:10:07">[00:10:07]</a>.

### Vue.js
*   **Popularity**: Independently developed <a class="yt-timestamp" data-t="00:10:17">[00:10:17]</a>. Has the most GitHub stars (187,000+) and is tied with Angular for second place in npm downloads <a class="yt-timestamp" data-t="00:10:31">[00:10:31]</a>.
*   **Philosophy**: Similar to Angular but more approachable for independent developers <a class="yt-timestamp" data-t="00:10:21">[00:10:21]</a>. Offers official packages for routing and state management, plus a large third-party ecosystem <a class="yt-timestamp" data-t="00:10:25">[00:10:25]</a>.
*   **Project Setup**: Powerful CLI, including a UI command for project generation <a class="yt-timestamp" data-t="00:10:37">[00:10:37]</a>. Generates a simplified project structure compared to Angular <a class="yt-timestamp" data-t="00:10:57">[00:10:57]</a>.
*   **Core Concepts**: Components are defined in `.vue` files with three parts: template, script, and styles <a class="yt-timestamp" data-t="00:11:09">[00:11:09]</a>. Components are plain JavaScript objects <a class="yt-timestamp" data-t="00:11:16">[00:11:16]</a>. Reactive data is defined in the `data` property <a class="yt-timestamp" data-t="00:11:20">[00:11:20]</a>. Methods are defined in the `methods` property <a class="yt-timestamp" data-t="00:11:25">[00:11:25]</a>. Lifecycle hooks like `mounted` are used for initialization <a class="yt-timestamp" data-t="00:11:31">[00:11:31]</a>. Templates use directives like `v-for` for looping and `v-on` for event handling <a class="yt-timestamp" data-t="00:11:47">[00:11:47]</a>. `v-on` can automatically prevent default behavior with `.prevent` <a class="yt-timestamp" data-t="00:11:57">[00:11:57]</a>. Two-way data binding uses `v-model` <a class="yt-timestamp" data-t="00:12:10">[00:12:10]</a>.
*   **Pros/Cons**: Offers many small conveniences that improve developer experience <a class="yt-timestamp" data-t="00:12:06">[00:12:06]</a>. Has a large community <a class="yt-timestamp" data-t="00:12:14">[00:12:14]</a>.

### Svelte
*   **Popularity**: Most loved framework in the 2021 Stack Overflow survey <a class="yt-timestamp" data-t="00:12:18">[00:12:18]</a>, with about 50,000 GitHub stars <a class="yt-timestamp" data-t="00:12:22">[00:12:22]</a>. Less common than React, Angular, or Vue, but highly regarded by its users <a class="yt-timestamp" data-t="00:12:24">[00:12:24]</a>.
*   **Philosophy**: Minimal library <a class="yt-timestamp" data-t="00:12:29">[00:12:29]</a>, relies on open-source for features like routing <a class="yt-timestamp" data-t="00:12:30">[00:12:30]</a>. Unique in that it functions as a compiler, turning code into plain JavaScript without shipping a runtime or virtual DOM to the browser <a class="yt-timestamp" data-t="00:12:34">[00:12:34]</a>.
*   **Project Setup**: May require learning about module bundlers like Rollup or Webpack <a class="yt-timestamp" data-t="00:12:45">[00:12:45]</a>.
*   **Core Concepts**: Components are defined in `.svelte` files with script, template, and styles sections <a class="yt-timestamp" data-t="00:13:00">[00:13:00]</a>. Reactive state is declared simply with the `let` keyword <a class="yt-timestamp" data-t="00:13:08">[00:13:08]</a>, and updated with plain JavaScript functions <a class="yt-timestamp" data-t="00:13:13">[00:13:13]</a>. Lifecycle hooks use functions like `onMount` <a class="yt-timestamp" data-t="00:13:23">[00:13:23]</a>. Templates use a special syntax for looping (e.g., `each`) <a class="yt-timestamp" data-t="00:13:30">[00:13:30]</a>. Event handlers like `on:submit` can include modifiers like `preventdefault` <a class="yt-timestamp" data-t="00:13:39">[00:13:39]</a>. Two-way data binding uses the `bind:value` directive <a class="yt-timestamp" data-t="00:13:46">[00:13:46]</a>.
*   **Pros/Cons**: Cleanest implementation, fewer lines of code, and feels natural for JavaScript developers <a class="yt-timestamp" data-t="00:13:52">[00:13:52]</a>. Smaller community can be a drawback for support or job opportunities <a class="yt-timestamp" data-t="00:14:02">[00:14:02]</a>.

### Lit
*   **Philosophy**: Google-sponsored project focused on [[understanding_the_unique_features_of_frameworks_like_svelte_lit_and_alpine_js | building web components]] <a class="yt-timestamp" data-t="00:14:15">[00:14:15]</a>, which are a browser standard allowing custom elements to work across frameworks <a class="yt-timestamp" data-t="00:14:20">[00:14:20]</a>. It simplifies the notoriously difficult web components API <a class="yt-timestamp" data-t="00:14:28">[00:14:28]</a>.
*   **Project Setup**: No official CLI, uses a starter project (TypeScript version available) <a class="yt-timestamp" data-t="00:14:45">[00:14:45]</a>. Directly uses the browser's `window.customElements` API <a class="yt-timestamp" data-t="00:14:54">[00:14:54]</a>.
*   **Core Concepts**: Components are classes extending `LitElement` <a class="yt-timestamp" data-t="00:15:03">[00:15:03]</a>. Reactive data is defined as properties on the class using the `@property` decorator <a class="yt-timestamp" data-t="00:15:07">[00:15:07]</a>. Lifecycle hooks are based on the web components API, like `connectedCallback` <a class="yt-timestamp" data-t="00:15:15">[00:15:15]</a>. Templates use existing JavaScript template literals (strings with backticks) allowing JavaScript interpolation into HTML <a class="yt-timestamp" data-t="00:15:26">[00:15:26]</a>. Directives are used for event binding (e.g., `submit`) and value binding (e.g., `.value`) <a class="yt-timestamp" data-t="00:15:47">[00:15:47]</a>.
*   **Pros/Cons**: Provides a much nicer way to build standard web components <a class="yt-timestamp" data-t="00:16:03">[00:16:03]</a>. Does not support two-way data binding <a class="yt-timestamp" data-t="00:15:53">[00:15:53]</a>.

### Stencil
*   **Philosophy**: From the Ionic Framework team, also focused on web components to make Ionic compatible with React, Angular, and Vue <a class="yt-timestamp" data-t="00:16:13">[00:16:13]</a>. Compiles components down to standard web components <a class="yt-timestamp" data-t="00:16:32">[00:16:32]</a>.
*   **Project Setup**: Create new app with `npm init stencil` <a class="yt-timestamp" data-t="00:16:27">[00:16:27]</a>, which provides a TypeScript project <a class="yt-timestamp" data-t="00:16:30">[00:16:30]</a>.
*   **Core Concepts**: Components are classes with a `@Component` decorator, similar to Angular <a class="yt-timestamp" data-t="00:16:37">[00:16:37]</a>. Reactive data uses the `@State` decorator <a class="yt-timestamp" data-t="00:16:41">[00:16:41]</a>. Lifecycle hooks like `componentWillLoad` are used <a class="yt-timestamp" data-t="00:16:48">[00:16:48]</a>. Templating uses JSX, similar to React <a class="yt-timestamp" data-t="00:16:58">[00:16:58]</a>.
*   **Pros/Cons**: Good for building web components <a class="yt-timestamp" data-t="00:17:16">[00:17:16]</a>. Does not appear to support two-way data binding <a class="yt-timestamp" data-t="00:17:07">[00:17:07]</a>.

### SolidJS
*   **Philosophy**: Inspired by React for building UI components <a class="yt-timestamp" data-t="00:17:23">[00:17:23]</a>, but does not use the virtual DOM <a class="yt-timestamp" data-t="00:17:27">[00:17:27]</a>. Compiles code down to native DOM nodes, similar to Svelte <a class="yt-timestamp" data-t="00:17:29">[00:17:29]</a>, leading to high performance <a class="yt-timestamp" data-t="00:17:33">[00:17:33]</a>.
*   **Project Setup**: Uses Vite as the build tool <a class="yt-timestamp" data-t="00:17:45">[00:17:45]</a>.
*   **Core Concepts**: Components are defined as functions in JSX files <a class="yt-timestamp" data-t="00:17:48">[00:17:48]</a>. Reactive state uses "signals," similar to React hooks <a class="yt-timestamp" data-t="00:17:54">[00:17:54]</a>. Lifecycle uses the `onMount` hook <a class="yt-timestamp" data-t="00:18:06">[00:18:06]</a>. UI is defined in JSX, identical to React code <a class="yt-timestamp" data-t="00:18:14">[00:18:14]</a>. Form values can be bound with `ref` without needing to import a specific hook <a class="yt-timestamp" data-t="00:18:23">[00:18:23]</a>.
*   **Pros/Cons**: Faster and more developer-friendly than React <a class="yt-timestamp" data-t="00:18:30">[00:18:30]</a>. Smaller community <a class="yt-timestamp" data-t="00:18:41">[00:18:41]</a>.

### Alpine.js
*   **Popularity**: Tiny library (~4 kilobytes) with over 17,000 GitHub stars <a class="yt-timestamp" data-t="00:18:56">[00:18:56]</a>. Often used as a replacement for jQuery <a class="yt-timestamp" data-t="00:19:00">[00:19:00]</a>.
*   **Philosophy**: Focuses on extending existing HTML with reactive data and framework-like features <a class="yt-timestamp" data-t="00:18:37">[00:18:37]</a>. Similar to how Tailwind functions for CSS, Alpine does for JavaScript, emphasizing HTML <a class="yt-timestamp" data-t="00:18:51">[00:18:51]</a>.
*   **Project Setup**: Add the Alpine script to the HTML head <a class="yt-timestamp" data-t="00:19:02">[00:19:02]</a>.
*   **Core Concepts**: Reactive data is stored directly in a DOM node using the `x-data` attribute <a class="yt-timestamp" data-t="00:19:06">[00:19:06]</a>. Data can be used in child elements with directives like `x-for` for looping <a class="yt-timestamp" data-t="00:19:10">[00:19:10]</a>. Event handling uses `x-on:submit` with `.prevent` <a class="yt-timestamp" data-t="00:19:16">[00:19:16]</a>. Concepts are similar to other frameworks but applied directly to raw HTML <a class="yt-timestamp" data-t="00:19:24">[00:19:24]</a>. JavaScript can be written in a script tag, using `Alpine.store` for shared data between components <a class="yt-timestamp" data-t="00:19:33">[00:19:33]</a>. Lifecycle events handled with `document.addEventListener` on `alpine:init` <a class="yt-timestamp" data-t="00:19:47">[00:19:47]</a>.
*   **Pros/Cons**: Excellent for adding minor interactivity to existing HTML pages <a class="yt-timestamp" data-t="00:20:00">[00:20:00]</a>. Not ideal for complex single-page applications where React, Vue, or Angular might be better <a class="yt-timestamp" data-t="00:20:09">[00:20:09]</a>.

### Mithril
*   **Philosophy**: Very lightweight and performs better than the larger frameworks <a class="yt-timestamp" data-t="00:20:20">[00:20:20]</a>. Uses a virtual DOM like React and Vue <a class="yt-timestamp" data-t="00:20:23">[00:20:23]</a>, but with a different developer experience <a class="yt-timestamp" data-t="00:20:26">[00:20:26]</a>.
*   **Project Setup**: Add the Mithril script tag to an `index.html` file <a class="yt-timestamp" data-t="00:20:29">[00:20:29]</a>.
*   **Core Concepts**: Components can be functions, classes, or plain JavaScript objects <a class="yt-timestamp" data-t="00:20:34">[00:20:34]</a>. Data and methods are added as properties on the object <a class="yt-timestamp" data-t="00:20:39">[00:20:39]</a>. Lifecycle hooks use special properties like `oninit` <a class="yt-timestamp" data-t="00:20:43">[00:20:43]</a>. The UI is defined using the `m` function, which creates DOM nodes with properties and children, making the UI truly pure JavaScript <a class="yt-timestamp" data-t="00:20:50">[00:20:50]</a>. Event handlers like `onsubmit` are defined on the `m` function <a class="yt-timestamp" data-t="00:21:07">[00:21:07]</a>.
*   **Pros/Cons**: Good for those who prefer to define UI purely in JavaScript <a class="yt-timestamp" data-t="00:21:16">[00:21:16]</a>. Can feel awkward for some developers <a class="yt-timestamp" data-t="00:21:21">[00:21:21]</a>.

## Conclusion
All these frameworks can achieve the same basic functionality <a class="yt-timestamp" data-t="00:21:41">[00:21:41]</a>. The choice ultimately comes down to personal preference and what makes a development team happy <a class="yt-timestamp" data-t="00:21:43">[00:21:43]</a>.