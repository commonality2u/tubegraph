---
title: Importance of breaking down large problems
videoId: UFc-RPbq8kg
---

From: [[fireship]] <br/> 
The ability to effectively break down large problems is considered one of the most important skills for a software developer <a class="yt-timestamp" data-t="00:00:23">[00:00:23]</a>. Experienced developers are recognized more for their [[problemsolving_skills_in_software_development | problem-solving skills]] than for memorizing every feature of a programming language <a class="yt-timestamp" data-t="00:00:57">[00:00:57]</a>. Top companies often use whiteboarding problems in interviews to gain insight into a candidate's thought process when approaching a [[problemsolving_skills_in_software_development | software development problem]] <a class="yt-timestamp" data-t="00:01:05">[00:01:05]</a>.

While there isn't one universal "right" way to solve a problem <a class="yt-timestamp" data-t="00:01:34">[00:01:34]</a>, a key strategy involves taking a large, complex problem and [[steps_to_solve_coding_problems | breaking it down into a bunch of smaller problems]] <a class="yt-timestamp" data-t="00:02:37">[00:02:37]</a>.

### Identifying and Understanding the Problem
The first step in [[steps_to_solve_coding_problems | problem-solving]] is to identify and understand the nature of the problem <a class="yt-timestamp" data-t="00:01:42">[00:01:42]</a>. It's often recommended to spend significantly more time understanding the problem (e.g., 55 minutes) than thinking about solutions (e.g., 5 minutes) <a class="yt-timestamp" data-t="00:01:45">[00:01:45]</a>.

Common software problems include:
*   **Internal Optimization** Trying to save time and money <a class="yt-timestamp" data-t="00:01:57">[00:01:57]</a>.
*   **Bugs** Troubleshooting existing software by analyzing application stack traces <a class="yt-timestamp" data-t="00:02:04">[00:02:04]</a>.
*   **Abstract Problems** Such as user experience issues, which are often broken down into "epic stories and themes" using the agile approach <a class="yt-timestamp" data-t="00:02:08">[00:02:08]</a>.

When defining a problem, it's useful to start with:
1.  **Context** What is the situation? <a class="yt-timestamp" data-t="00:02:19">[00:02:19]</a>
2.  **Issue** Why is this a problem? <a class="yt-timestamp" data-t="00:02:24">[00:02:24]</a>
3.  **Summary** Why should this problem be solved? <a class="yt-timestamp" data-t="00:02:28">[00:02:28]</a>

### Researching and Refining Sub-problems
After defining the main problem, [[steps_to_solve_coding_problems | breaking it down into smaller problems]] allows for more focused research and refinement <a class="yt-timestamp" data-t="00:02:37">[00:02:37]</a>. For example, a problem of merging 600 pull requests might be broken down into:
1.  Validating each pull request <a class="yt-timestamp" data-t="00:03:50">[00:03:50]</a>.
2.  Retrieving all pull requests from GitHub <a class="yt-timestamp" data-t="00:04:10">[00:04:10]</a>.
3.  Merging each one individually <a class="yt-timestamp" data-t="00:04:12">[00:04:12]</a>.

Researching how others have solved similar problems is encouraged, as it's rare to be the first to encounter a specific issue <a class="yt-timestamp" data-t="00:03:10">[00:03:10]</a>. It's also important to discuss ideas with other developers and weigh the pros and cons of alternative approaches <a class="yt-timestamp" data-t="00:03:29">[00:03:29]</a>.

### Pseudocode and Implementation
Once sub-problems are identified and researched, the next step is to create pseudocode, which outlines the logic without worrying about specific syntax or implementation details <a class="yt-timestamp" data-t="00:04:39">[00:04:39]</a>. This focus on logic and naming conventions helps increase code readability <a class="yt-timestamp" data-t="00:05:27">[00:05:27]</a>.

A "big problem is a collection of small steps" <a class="yt-timestamp" data-t="00:08:07">[00:08:07]</a>. Trying to perfect every small step can be discouraging and prolong the development process <a class="yt-timestamp" data-t="00:08:08">[00:08:08]</a>. It is often more effective to quickly implement an initial working prototype, even if the code isn't perfect, to gain confidence that the problem can be solved <a class="yt-timestamp" data-t="00:08:21">[00:08:21]</a>. After achieving a working solution for the smaller parts, developers can then reflect and improve the code by focusing on aspects like readability, removing duplication, optimizing [[data_structures_and_algorithms | algorithms]], adding caching, and improving error handling <a class="yt-timestamp" data-t="00:09:01">[00:09:01]</a>. It's easier to improve a working piece of code than to write a perfect one from the start <a class="yt-timestamp" data-t="00:09:16">[00:09:16]</a>.