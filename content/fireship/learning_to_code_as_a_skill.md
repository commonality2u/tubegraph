---
title: Learning to code as a skill
videoId: NtfbWkxJTHw
---

From: [[fireship]] <br/> 

Contrary to popular belief, statements like "everybody needs to learn to code" or "coding is the new literacy" are not entirely true, nor is the idea that "coding is easy" <a class="yt-timestamp" data-t="00:00:00">[00:00:00]</a>. Learning to code is a skill, and like any skill, it requires specific techniques and dedication to master <a class="yt-timestamp" data-t="00:00:14">[00:00:14]</a>.

## Overcoming Initial Challenges

The journey into programming often starts with personal motivation, such as a desire to escape a low-paying job or to build an app <a class="yt-timestamp" data-t="00:00:24">[00:00:24]</a>. Initial attempts might lead to self-doubt, as exemplified by a personal anecdote of failing to grasp PHP and MySQL <a class="yt-timestamp" data-t="00:00:32">[00:00:32]</a>. However, perseverance, even with simpler tasks like learning HTML to build a family website, can lead to shipping a first project <a class="yt-timestamp" data-t="00:00:44">[00:00:44]</a>.

A crucial insight for aspiring coders is that hard work is more valuable than inherent talent <a class="yt-timestamp" data-t="00:00:52">[00:00:52]</a>. While "10x developers" exist where concepts click more easily, programming is akin to learning a musical instrument or juggling; one starts by being "terrible," experiences moments of genius, and then cycles back to realizing there's more to learn <a class="yt-timestamp" data-t="00:01:00">[00:01:00]</a>.

## The Nature of Programming Pain

Learning is inherently painful, and this "pain" is necessary for growth <a class="yt-timestamp" data-t="00:01:12">[00:01:12]</a>. Just as guitarists endure fingertip pain to build calluses, programmers must endure hitting their heads against the keyboard to resolve error messages <a class="yt-timestamp" data-t="00:01:16">[00:01:16]</a>. Embracing this hard work is essential, especially if one doesn't possess natural talent <a class="yt-timestamp" data-t="00:01:26">[00:01:26]</a>.

## Language Agnostic [[problemsolving_and_coding_practice | Problem Solving]]

When starting, the choice of [[beginner_programming_languages_and_learning_tools | programming language]] is less critical than becoming proficient in one <a class="yt-timestamp" data-t="00:01:30">[00:01:30]</a>. It's impossible to retain every detail of every language, and memorizing syntax is not the main goal <a class="yt-timestamp" data-t="00:01:37">[00:01:37]</a>. The key is to learn and retain programming patterns, which are essentially [[problemsolving_and_coding_practice | problem solving]] techniques <a class="yt-timestamp" data-t="00:01:47">[00:01:47]</a>.

The ability to solve problems applies across languages. For example, understanding the trade-offs between different types of loops (for, while, recursion) is more valuable than knowing their specific syntax in a new language like Perl <a class="yt-timestamp" data-t="00:01:57">[00:01:57]</a>. This is why technical interviews often prioritize [[problemsolving_and_coding_practice | problem-solving skills]] and may even involve writing pseudocode <a class="yt-timestamp" data-t="00:02:06">[00:02:06]</a>.

### Recommended Languages for Beginners:
It's advisable to try a few languages and stick with the one that feels most natural <a class="yt-timestamp" data-t="00:02:18">[00:02:18]</a>. Python is often recommended due to its minimal syntax, popularity, and general utility <a class="yt-timestamp" data-t="00:02:22">[00:02:22]</a>. Other good starting [[beginner_programming_languages_and_learning_tools | languages]] include JavaScript, Go, Kotlin, and Swift <a class="yt-timestamp" data-t="00:02:30">[00:02:30]</a>. The focus remains on becoming a [[problemsolving_and_coding_practice | problem solver]], not just a syntax memorizer <a class="yt-timestamp" data-t="00:02:34">[00:02:34]</a>.

## Becoming a [[problemsolving_and_coding_practice | Problem Solver]] Through Practice

The most effective way to become a good [[problemsolving_and_coding_practice | problem solver]] is to actively solve problems by writing code <a class="yt-timestamp" data-t="00:02:38">[00:02:38]</a>. Watching tutorials or reading books alone is insufficient; one must code along with them <a class="yt-timestamp" data-t="00:02:44">[00:02:44]</a>.

### Practical Practice Methods:
*   Building projects based on tutorials <a class="yt-timestamp" data-t="00:03:00">[00:03:00]</a>
*   Attempting to build personal projects <a class="yt-timestamp" data-t="00:03:03">[00:03:03]</a>
*   Participating in coding challenges <a class="yt-timestamp" data-t="00:03:04">[00:03:04]</a>
*   Engaging in hackathons <a class="yt-timestamp" data-t="00:03:05">[00:03:05]</a>

Serious learners should aim to code at least a couple of hours every day, as experience (or "flying hours") is paramount <a class="yt-timestamp" data-t="00:03:08">[00:03:08]</a>.

## Health and Learning Efficiency

Sustained coding can be physically and mentally demanding <a class="yt-timestamp" data-t="00:03:22">[00:03:22]</a>. It's crucial to prioritize health, both mental and physical, through activities like getting sunshine and exercise <a class="yt-timestamp" data-t="00:03:27">[00:03:27]</a>. Suboptimal health hinders learning efficiency, and no activity is worth sacrificing well-being for <a class="yt-timestamp" data-t="00:03:40">[00:03:40]</a>.

## The Feynman Technique for [[importance_of_learning_new_skills_and_efficient_problemsolving | Efficient Learning]]

Nobel Prize-winning physicist Richard Feynman's learning technique can be applied to programming <a class="yt-timestamp" data-t="00:03:48">[00:03:48]</a>. This method suggests that one learns most efficiently by attempting to teach the concept they are learning <a class="yt-timestamp" data-t="00:04:02">[00:04:02]</a>.

### Steps of the Feynman Technique:
1.  **Choose a concept**: Select a programming topic you want to understand <a class="yt-timestamp" data-t="00:04:35">[00:04:35]</a>.
2.  **Explain to a 12-year-old**: Write a summary explaining the technology in simple terms <a class="yt-timestamp" data-t="00:04:41">[00:04:41]</a>.
3.  **Build something**: Create a full working demo as quickly as possible <a class="yt-timestamp" data-t="00:04:43">[00:04:43]</a>. It doesn't need to be perfect initially <a class="yt-timestamp" data-t="00:04:46">[00:04:46]</a>.
4.  **Refine and simplify**: Go back to refactor, simplify, improve the process, and seek feedback from experienced individuals <a class="yt-timestamp" data-t="00:04:48">[00:04:48]</a>.

This technique is effective because it forces precision in understanding and reveals knowledge gaps <a class="yt=" data-t="00:04:31">[00:04:31]</a>. Even pretending to teach is beneficial, but creating content like videos or blog posts, mentoring others, helping on Slack/Discord channels, or answering Stack Overflow questions can amplify learning <a class="yt-timestamp" data-t="00:04:14">[00:04:14]</a>.

## Creating Positive Feedback Loops

Learning, while painful, needs rewards <a class="yt-timestamp" data-t="00:05:06">[00:05:06]</a>. Getting to a working demo quickly creates a positive feedback loop that can make one "addicted to coding" <a class="yt-timestamp" data-t="00:05:10">[00:05:10]</a>.

A practical way to achieve this is by setting small, achievable goals daily and marking them as complete <a class="yt-timestamp" data-t="00:05:21">[00:05:21]</a>. Completing goals releases dopamine, which reinforces positive behavior <a class="yt-timestamp" data-t="00:05:28">[00:05:28]</a>. Without these dopamine hits, learning can lead to a negative feedback loop and quickly make one hate coding <a class="yt-timestamp" data-t="00:05:34">[00:05:34]</a>.

## Pacing and Breaks

While hard work is essential, overworking is detrimental <a class="yt-timestamp" data-t="00:05:46">[00:05:46]</a>. Pacing oneself and taking regular breaks is crucial for programmers <a class="yt-timestamp" data-t="00:05:48">[00:05:48]</a>. Typically, one or two hours of programming followed by a long break is effective <a class="yt-timestamp" data-t="00:05:52">[00:05:52]</a>.

Often, problems that seem insurmountable late at night can be immediately solved after a good night's sleep <a class="yt-timestamp" data-t="00:05:57">[00:05:57]</a>. This highlights the importance of "mental spacing" and recognizing when one is mentally exhausted <a class="yt-timestamp" data-t="00:06:10">[00:06:10]</a>. The most efficient approach when stuck is often to step away, get sunshine, and get some sleep <a class="yt-timestamp" data-t="00:06:18">[00:06:18]</a>.

Ultimately, learning to code is about continuous problem-solving, and utilizing online resources like Google will be a constant companion throughout a software engineer's career <a class="yt-timestamp" data-t="00:06:27">[00:06:27]</a>.