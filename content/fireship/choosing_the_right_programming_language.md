---
title: Choosing the right programming language
videoId: NtfbWkxJTHw
---

From: [[fireship]] <br/> 

Many common statements about learning to code are not true, such as "everybody needs to learn to code," "coding is the new literacy," or "coding is easy" <a class="yt-timestamp" data-t="00:00:00">[00:00:00]</a>. Learning itself is a skill, and becoming a software engineer requires continuous learning <a class="yt-timestamp" data-t="00:17:15">[00:17:15]</a>.

## Hard Work Over Talent
When learning to code, it's important to recognize that hard work is more valuable than inherent talent <a class="yt-timestamp" data-t="00:51:30">[00:51:30]</a>. While some "10x developers" may grasp concepts more quickly, programming is a skill, much like playing a musical instrument or juggling <a class="yt-timestamp" data-t="00:59:15">[00:59:15]</a>. Initial struggles are common; one might feel like a genius after writing a first program, only to "suck again," a pattern that repeats <a class="yt-timestamp" data-t="01:04:47">[01:04:47]</a>. Learning involves pain, such as repeatedly encountering error messages until a solution is found <a class="yt-timestamp" data-t="01:13:08">[01:13:08]</a>. Therefore, if you don't consider yourself talented, be prepared to embrace hard work <a class="yt-timestamp" data-t="01:26:00">[01:26:00]</a>.

## Does Your First Programming Language Matter?
When starting out, the specific programming language chosen for [[beginner_programming_languages_and_learning_tools | learning to code]] doesn't matter as much as becoming proficient in one of them <a class="yt-timestamp" data-t="01:30:00">[01:30:00]</a>. Programming involves a vast amount of knowledge, and it's impossible to retain it all <a class="yt-timestamp" data-t="01:35:00">[01:35:00]</a>. Memorizing syntax is not the most crucial aspect; instead, the focus should be on learning and retaining "programming patterns" <a class="yt-timestamp" data-t="01:44:48">[01:44:48]</a>.

Essentially, programming is problem-solving <a class="yt-timestamp" data-t="01:50:00">[01:50:00]</a>. The goal is to build a repertoire of tools in your mind that can be applied to solve nearly any problem in any language <a class="yt-timestamp" data-t="01:53:00">[01:53:00]</a>. For instance, understanding the trade-offs between `for` loops, `while` loops, and recursion is more valuable than knowing the specific syntax in a new language like Perl <a class="yt-timestamp" data-t="01:59:00">[01:59:00]</a>. This is why technical interviews often prioritize problem-solving skills, sometimes even allowing pseudocode on a whiteboard, over specific language knowledge <a class="yt-timestamp" data-t="02:06:00">[02:06:00]</a>.

### Recommended Starting Languages
It's advisable to try out a few different [[popular_programming_languages_for_web_development | programming languages]] and stick with the one that feels most natural <a class="yt-timestamp" data-t="02:18:00">[02:18:00]</a>.

For many beginners, **Python** is ideal due to its:
*   Minimal syntax <a class="yt-timestamp" data-t="02:22:00">[02:22:00]</a>
*   Extreme popularity <a class="yt-timestamp" data-t="02:24:00">[02:24:00]</a>
*   General utility <a class="yt-timestamp" data-t="02:26:00">[02:26:00]</a>

Other good starting languages include:
*   JavaScript <a class="yt-timestamp" data-t="02:30:00">[02:30:00]</a>
*   Go <a class="yt-timestamp" data-t="02:30:00">[02:30:00]</a>
*   Kotlin <a class="yt-timestamp" data-t="02:30:00">[02:30:00]</a>
*   Swift <a class="yt-timestamp" data-t="02:30:00">[02:30:00]</a>

The core objective is to become a problem solver, not merely someone who memorizes syntax <a class="yt-timestamp" data-t="02:34:00">[02:34:00]</a>.

## Becoming a Problem Solver
The path to becoming a good problem solver is to actively solve problems <a class="yt-timestamp" data-t="02:38:00">[02:38:00]</a>. Watching tutorials or reading books alone is insufficient; active coding is essential, much like playing a guitar alongside a video rather than just watching <a class="yt-timestamp" data-t="02:44:00">[02:44:00]</a>.

To develop problem-solving skills:
*   Code along with tutorials <a class="yt-timestamp" data-t="02:55:00">[02:55:00]</a>.
*   Build your own projects <a class="yt-timestamp" data-t="03:02:00">[03:02:00]</a>.
*   Engage in coding challenges <a class="yt-timestamp" data-t="03:04:00">[03:04:00]</a>.
*   Participate in hackathons <a class="yt-timestamp" data-t="03:05:00">[03:05:00]</a>.

Consistent practice, such as coding for at least a couple of hours daily, builds experience, which is paramount <a class="yt-timestamp" data-t="03:08:00">[03:08:00]</a>.

## The Feynman Learning Technique
Nobel Prize-winning physicist Richard Feynman's learning technique can be applied to programming <a class="yt-timestamp" data-t="03:47:00">[03:47:00]</a>:
1.  **Choose a concept:** Select a topic you want to understand deeply <a class="yt-timestamp" data-t="03:54:00">[03:54:00]</a>.
2.  **Explain it to a 12-year-old:** Simplify the concept until it's understandable by a child <a class="yt-timestamp" data-t="03:56:00">[03:56:00]</a>.
3.  **Reflect, refine, simplify:** Identify gaps in your understanding and simplify your explanation <a class="yt-timestamp" data-t="03:58:00">[03:58:00]</a>.
4.  **Organize and review:** Structure your explanation and review it <a class="yt-timestamp" data-t="04:00:00">[04:00:00]</a>.

This means that teaching what you're learning is one of the most efficient ways to solidify your knowledge <a class="yt-timestamp" data-t="04:02:00">[04:02:00]</a>. You can apply this by:
*   Pretending to teach a concept <a class="yt-timestamp" data-t="04:14:00">[04:14:00]</a>.
*   Creating content like videos or blog posts <a class="yt-timestamp" data-t="04:16:00">[04:16:00]</a>.
*   Mentoring others if you're employed <a class="yt-timestamp" data-t="04:20:00">[04:20:00]</a>.
*   Joining programming Slack or Discord channels to help others <a class="yt-timestamp" data-t="04:24:00">[04:24:00]</a>.
*   Answering questions on platforms like Stack Overflow <a class="yt-timestamp" data-t="04:28:00">[04:28:00]</a>.

Helping others forces you to be precise about what you know <a class="yt-timestamp" data-t="04:31:00">[04:31:00]</a>. For a programmer, this could mean researching a topic like video game programming, summarizing the technology for a 12-year-old, building a working demo quickly, and then refactoring and seeking feedback <a class="yt-timestamp" data-t="04:35:00">[04:35:00]</a>.

## Importance of Positive Feedback Loops
While learning can be painful, it needs to be balanced with rewards to create a positive feedback loop that fosters addiction to coding <a class="yt-timestamp" data-t="05:06:00">[05:06:00]</a>. Achieving small, achievable goals, such as daily tasks, releases dopamine, which reinforces the desire to continue <a class="yt-timestamp" data-t="05:19:00">[05:19:00]</a>. Without these rewards, programming can quickly become frustrating <a class="yt-timestamp" data-t="05:34:00">[05:34:00]</a>.

### Pacing and Breaks
It's crucial to pace yourself and take regular breaks to avoid burnout <a class="yt-timestamp" data-t="05:46:00">[05:46:00]</a>. Often, a problem that seems insurmountable late at night can be immediately solved after a good night's sleep <a class="yt-timestamp" data-t="05:57:00">[05:57:00]</a>. Mental spacing is vital; even if your ego urges you to continue, stepping away for sunshine, exercise, or sleep can lead to more efficient learning <a class="yt-timestamp" data-t="06:09:00">[06:09:00]</a>.

Ultimately, once you understand these learning principles, Google can become your primary guide, as searching for solutions is a fundamental part of being a software engineer <a class="yt-timestamp" data-t="06:27:00">[06:27:00]</a>.