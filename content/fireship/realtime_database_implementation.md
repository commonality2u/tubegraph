---
title: RealTime Database Implementation
videoId: ucmbO2lWC2A
---

From: [[fireship]] <br/> 

Both Firebase and AWS Amplify provide ways for app developers to manage [[framework_features_like_routing_and_database_integration | database integration]] and scale their cloud infrastructure, including solutions for [[realtime_database_and_user_authentication_with_pocketbase | realtime data]] handling <a class="yt-timestamp" data-t="00:00:06">[00:00:06]</a>. This comparison focuses on how each platform approaches [[realtime_database_and_user_authentication_with_pocketbase | realtime data]] management, particularly with Firebase's Firestore and Amplify's GraphQL/AppSync integration <a class="yt-timestamp" data-t="00:02:28">[00:02:28]</a>.

## Common Features
Both Firebase and AWS Amplify share several core features, including a way to manage [[realtime_database_and_user_authentication_with_pocketbase | realtime data]] <a class="yt-timestamp" data-t="00:01:28">[00:01:28]</a>.

## Firebase Firestore for [[realtime_database_and_user_authentication_with_pocketbase | Realtime Data]]
Firebase offers a dedicated [[database_options_for_web_applications | database]] solution with Firestore, a NoSQL [[database_options_for_web_applications | database]] <a class="yt-timestamp" data-t="00:02:26">[00:02:26]</a> <a class="yt-timestamp" data-t="00:10:13">[00:10:13]</a>.

### Key Aspects of Firestore
*   **Realtime Syncing**: With Firestore, real-time syncing of data happens automatically, and billing is based on reads and writes to the [[database_options_for_web_applications | database]] <a class="yt-timestamp" data-t="00:04:11">[00:04:11]</a> <a class="yt-timestamp" data-t="00:10:07">[00:10:07]</a>.
*   **Ease of Use**: [[working_with_firebase_firestore_and_realtime_updates | Implementing realtime updates]] with Firestore is designed for simplicity, requiring minimal boilerplate code <a class="yt-timestamp" data-t="00:09:59">[00:09:59]</a>. For example, querying a collection for [[realtime_database_and_user_authentication_with_pocketbase | realtime updates]] can be done by calling `onSnapshot` on the collection reference, which provides a callback function that listens to any changes <a class="yt-timestamp" data-t="00:09:26">[00:09:26]</a>. Updating a specific item involves making a reference to its location and calling `update` with the new data <a class="yt-timestamp" data-t="00:09:45">[00:09:45]</a>.
*   **Pricing**: For 1 million read operations, Firestore costs approximately $0.60, and for 1 million write operations, it costs about $1.80 <a class="yt-timestamp" data-t="00:04:31">[00:04:31]</a>. Billing is calculated per read/write, not in chunks of data size <a class="yt-timestamp" data-t="00:04:47">[00:04:47]</a>. This pricing model generally appears to be significantly less expensive as an app scales up compared to AWS AppSync with DynamoDB <a class="yt-timestamp" data-t="00:04:49">[00:04:49]</a>.
*   **Drawback**: The primary drawback of Firestore is that developers are constrained to working with a single NoSQL [[database_options_for_web_applications | database]], which can present challenges for [[secure_and_efficient_data_modeling_for_chat_applications | data modeling]] and data migration <a class="yt-timestamp" data-t="00:10:11">[00:10:11]</a>.

## AWS Amplify with GraphQL and AppSync for [[realtime_database_and_user_authentication_with_pocketbase | Realtime Data]]
AWS Amplify achieves [[realtime_database_and_user_authentication_with_pocketbase | realtime data]] capabilities primarily through its integration with GraphQL and AWS AppSync <a class="yt-timestamp" data-t="00:02:10">[00:02:10]</a> <a class="yt-timestamp" data-t="00:10:21">[00:10:21]</a>.

### Key Aspects of Amplify's Approach
*   **Provisioning**: To enable GraphQL and AppSync, users run `amplify add api` and select GraphQL. An API authentication type is also chosen <a class="yt-timestamp" data-t="00:10:25">[00:10:25]</a>.
*   **Schema Generation**: The Amplify CLI helps generate GraphQL schema boilerplate code. The default schema can often match existing frontend data types <a class="yt-timestamp" data-t="00:10:37">[00:10:37]</a>. After pushing to the cloud, Amplify automatically generates the GraphQL API <a class="yt-timestamp" data-t="00:10:54">[00:10:54]</a>.
*   **Backend [[database_options_for_web_applications | Database]] (DynamoDB)**: The GraphQL API connects to a backend [[database_options_for_web_applications | database]], typically DynamoDB, which is a NoSQL [[database_options_for_web_applications | database]] roughly equivalent to MongoDB or Firestore <a class="yt-timestamp" data-t="00:11:27">[00:11:27]</a> <a class="yt-timestamp" data-t="00:11:30">[00:11:30]</a>.
*   **Querying and Mutations**: To fetch data, the Apollo client is commonly used. Queries are made to the GraphQL endpoint, which returns a promise resolving to the data <a class="yt-timestamp" data-t="00:11:59">[00:11:59]</a>. Mutations (updates) are performed using `client.mutate` <a class="yt-timestamp" data-t="00:12:51">[00:12:51]</a>.
*   **Realtime Subscriptions**: To listen for [[realtime_database_and_user_authentication_with_pocketbase | real-time changes]], a subscription is set up using `client.subscribe`, which points to an `onUpdate` subscription query. This grants access to data whenever it changes <a class="yt-timestamp" data-t="00:13:02">[00:13:02]</a>.
*   **Pricing**: AWS AppSync charges $4 per 1 million query or write operations <a class="yt-timestamp" data-t="00:04:27">[00:04:27]</a>. Additionally, there can be extra costs associated with the underlying DynamoDB [[database_options_for_web_applications | database]] itself <a class="yt-timestamp" data-t="00:04:37">[00:04:37]</a>. Billing for DynamoDB is calculated in chunks of 5 kilobytes; a 100-kilobyte document would equate to 50 document read units <a class="yt-timestamp" data-t="00:04:41">[00:04:41]</a>.

## Comparison of [[realtime_database_and_user_authentication_with_pocketbase | Realtime Data]] Approaches
*   **Complexity vs. Flexibility**:
    *   **Firebase Firestore** offers simplicity and ease of setup for [[realtime_database_and_user_authentication_with_pocketbase | real-time data]] without much boilerplate code <a class="yt-timestamp" data-t="00:09:59">[00:09:59]</a>. It handles complex [[realtime_database_and_user_authentication_with_pocketbase | real-time features]] automatically <a class="yt-timestamp" data-t="00:10:06">[00:10:06]</a>.
    *   **AWS Amplify with GraphQL/AppSync** provides greater flexibility and control, allowing developers to make the code behave exactly as desired <a class="yt-timestamp" data-t="00:13:49">[00:13:49]</a>. However, this comes with more complexity, including more boilerplate code and implementation details <a class="yt-timestamp" data-t="00:13:41">[00:13:41]</a>. GraphQL, while powerful, can sometimes be overkill <a class="yt-timestamp" data-t="00:13:37">[00:13:37]</a>.
*   **Pricing**: While both platforms have generous free tiers, Firestore appears to be significantly less expensive for [[realtime_database_and_user_authentication_with_pocketbase | real-time data]] as an app scales up compared to AWS AppSync with DynamoDB <a class="yt-timestamp" data-t="00:04:49">[00:04:49]</a>.
*   **Developer Experience**: Both SDKs provide well-organized JavaScript libraries that allow developers to accomplish tasks with very few lines of code <a class="yt-timestamp" data-t="00:08:39">[00:08:39]</a>. However, Firebase is generally easier to use with fewer decisions needed for configuration, especially when comparing its [[using_firebase_databases_and_data_modeling_techniques | database solution]] to GraphQL and DynamoDB <a class="yt-timestamp" data-t="00:14:14">[00:14:14]</a>.