---
title: Overcoming challenges and hard work in programming
videoId: NtfbWkxJTHw
---

From: [[fireship]] <br/> 

Common statements like "everyone needs to learn to code," "coding is the new literacy," or "coding is easy" are not true, despite being used as fear-based sales tactics <a class="yt-timestamp" data-t="00:00:00">[00:00:00]</a>. Learning to code is a skill, and becoming a software engineer requires continuous learning <a class="yt-timestamp" data-t="00:00:17">[00:00:17]</a>.

## The Value of Hard Work Over Talent

When learning to code, it's important to understand that hard work is more valuable than inherent talent <a class="yt-timestamp" data-t="00:00:51">[00:00:51]</a>. While some "10x developers" may grasp things quickly, programming is a skill similar to playing a musical instrument or juggling <a class="yt-timestamp" data-t="00:01:00">[00:01:00]</a>. Initially, you might feel inept, then like a genius after a small success, only to feel inept again, in a continuous loop <a class="yt-timestamp" data-t="00:01:04">[00:01:04]</a>.

Growth through pain is a necessary part of the learning process <a class="yt-timestamp" data-t="00:01:14">[00:01:14]</a>. Just as guitarists endure finger pain to build calluses, programmers must persevere through error messages until solutions are found <a class="yt-timestamp" data-t="00:01:16">[00:01:16]</a>. If talent isn't present, embracing hard work is essential <a class="yt-timestamp" data-t="00:01:26">[00:01:26]</a>.

## [[Choosing the right programming language | Language Agnostic Problem Solving]]

When starting, the specific [[choosing_the_right_programming_language | programming language]] chosen is less critical than becoming proficient in at least one <a class="yt-timestamp" data-t="00:01:30">[00:01:30]</a>. The vast amount of information in programming means full retention is impossible, and memorizing syntax is not the main goal <a class="yt-timestamp" data-t="00:01:35">[00:01:35]</a>.

The core skill to develop and retain is understanding [[problemsolving_and_coding_practice | programming patterns]] and [[problemsolving_and_coding_practice | problem solving]] <a class="yt-timestamp" data-t="00:01:47">[00:01:47]</a>. This means building a mental repertoire of tools to solve problems across various languages <a class="yt-timestamp" data-t="00:01:53">[00:01:53]</a>. For instance, understanding the trade-offs between `for` loops, `while` loops, and recursion applies universally, even in an unfamiliar language like Perl <a class="yt-timestamp" data-t="00:01:59">[00:01:59]</a>. This focus on [[problemsolving_and_coding_practice | problem-solving skills]] is why technical interviews often don't prioritize a specific language, sometimes even allowing pseudocode on a whiteboard <a class="yt-timestamp" data-t="00:02:06">[00:02:06]</a>.

It's recommended to try a few different languages to find one that feels natural <a class="yt-timestamp" data-t="00:02:18">[00:02:18]</a>. Python is often considered ideal due to its minimal syntax, popularity, and general utility <a class="yt-timestamp" data-t="00:02:22">[00:02:22]</a>. Other good starting languages include JavaScript, Go, Kotlin, and Swift <a class="yt-timestamp" data-t="00:02:30">[00:02:30]</a>. The ultimate goal is to become a [[problemsolving_and_coding_practice | problem solver]], not just a syntax memorizer <a class="yt-timestamp" data-t="00:02:34">[00:02:34]</a>.

## Practice: The Path to Problem Solving

To become a good [[problemsolving_and_coding_practice | problem solver]], the most direct answer is to solve many problems <a class="yt-timestamp" data-t="00:02:38">[00:02:38]</a>. Just as you can't learn guitar by only watching others, you must actively write code <a class="yt-timestamp" data-t="00:02:45">[00:02:45]</a>. Books and tutorials are useful, but only if you code along with them <a class="yt-timestamp" data-t="00:02:50">[00:02:50]</a>.

Methods for active practice include:
*   Building things based on tutorials <a class="yt-timestamp" data-t="00:03:01">[00:03:01]</a>
*   Attempting to build your own projects <a class="yt-timestamp" data-t="00:03:03">[00:03:03]</a>
*   Engaging in [[problemsolving_and_coding_practice | coding challenges]] <a class="yt-timestamp" data-t="00:03:04">[00:03:04]</a>
*   Participating in hackathons <a class="yt-timestamp" data-t="00:03:05">[00:03:05]</a>

Serious learners should aim to be [[effectiveness_of_programming_in_spare_time | coding at least a couple hours every day]] <a class="yt-timestamp" data-t="00:03:09">[00:03:09]</a>. Experience is paramount in programming, much like flying hours for pilots <a class="yt-timestamp" data-t="00:03:13">[00:03:13]</a>.

## [[Mental and physical health in programming | Health and Well-being]] for Programmers

Prolonged sitting in front of a computer is unnatural and unhealthy <a class="yt-timestamp" data-t="00:03:22">[00:03:22]</a>. Programmers must actively work to protect their [[mental_and_physical_health_in_programming | health]], both mentally and physically <a class="yt-timestamp" data-t="00:03:27">[00:03:27]</a>. Eating well, getting sunshine, and exercising are crucial to offset the time spent coding <a class="yt-timestamp" data-t="00:03:34">[00:03:34]</a>. Suboptimal [[mental_and_physical_health_in_programming | health]] hinders learning efficiency, and no activity is worth sacrificing your well-being for <a class="yt-timestamp" data-t="00:03:40">[00:03:40]</a>.

## The Feynman Technique: Teach to Learn

Nobel Prize-winning physicist Richard Feynman's learning technique can be applied to programming <a class="yt-timestamp" data-t="00:03:47">[00:03:47]</a>. The technique involves:
1.  **Choose a concept**: Select something you want to learn <a class="yt-timestamp" data-t="00:03:54">[00:03:54]</a>.
2.  **Explain it to a 12-year-old**: Simplify the concept as if teaching it to a child <a class="yt-timestamp" data-t="00:03:56">[00:03:56]</a>.
3.  **Reflect, refine, simplify**: Identify gaps in your understanding and simplify your explanation <a class="yt-timestamp" data-t="00:03:58">[00:03:58]</a>.
4.  **Organize and review**: Structure your understanding and review it <a class="yt-timestamp" data-t="00:04:00">[00:04:00]</a>.

The most efficient way to learn is by attempting to teach what you're learning <a class="yt-timestamp" data-t="00:04:02">[00:04:02]</a>. For programmers, this could involve:
*   Pretending to teach a concept <a class="yt-timestamp" data-t="00:04:14">[00:04:14]</a>.
*   Creating valuable content like videos or blog posts <a class="yt-timestamp" data-t="00:04:16">[00:04:16]</a>.
*   Mentoring others at work <a class="yt-timestamp" data-t="00:04:20">[00:04:20]</a>.
*   Helping people in programming Slack/Discord channels or answering questions on Stack Overflow <a class="yt-timestamp" data-t="00:04:24">[00:04:24]</a>.

Helping others forces precise understanding <a class="yt-timestamp" data-t="00:04:31">[00:04:31]</a>. For a programmer, this might look like:
1.  Choosing a topic (e.g., programming a video game) <a class="yt-timestamp" data-t="00:04:35">[00:04:35]</a>.
2.  Researching, experimenting, and writing a summary explaining the technology simply <a class="yt-timestamp" data-t="00:04:38">[00:04:38]</a>.
3.  Building a full working demo as quickly as possible <a class="yt-timestamp" data-t="00:04:43">[00:04:43]</a>.
4.  Refactoring, simplifying, and improving the process, ideally getting feedback from someone more experienced <a class="yt-timestamp" data-t="00:04:48">[00:04:48]</a>.

## Positive Feedback Loops and Pacing

Learning should be painful, but it also requires rewards to create a positive feedback loop that can make you "addicted" to coding <a class="yt-timestamp" data-t="00:05:06">[00:05:06]</a>. A way to achieve this is by setting small, achievable goals each day <a class="yt-timestamp" data-t="00:05:19">[00:05:19]</a>. Checking off these goals triggers dopamine release in the brain, reinforcing the activity <a class="yt-timestamp" data-t="00:05:26">[00:05:26]</a>. Without these positive reinforcements, you might develop a negative feedback loop and hate coding <a class="yt-timestamp" data-t="00:05:34">[00:05:34]</a>.

While working hard, it's crucial to pace yourself and take regular breaks, especially in programming <a class="yt-timestamp" data-t="00:05:46">[00:05:46]</a>. Typically, one or two hours of programming followed by a long break is effective <a class="yt-timestamp" data-t="00:05:51">[00:05:51]</a>. It's common to struggle with error messages late into the night, only to solve the problem immediately after a good night's sleep <a class="yt-timestamp" data-t="00:05:57">[00:05:57]</a>. Mental spacing is vital; even if your ego pushes you to continue, going outside, getting sunshine, or resting can lead to a breakthrough <a class="yt-timestamp" data-t="00:06:10">[00:06:10]</a>.

Ultimately, learning to code involves continuous [[problemsolving_and_coding_practice | problem solving]] and using resources like Google as your guide <a class="yt-timestamp" data-t="00:06:28">[00:06:28]</a>.