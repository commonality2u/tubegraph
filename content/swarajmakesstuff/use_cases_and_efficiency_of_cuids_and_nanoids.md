---
title: Use cases and efficiency of CUIDs and Nanoids
videoId: toszy9D3kgE
---

From: [[swarajmakesstuff]] <br/> 

Historically, UUIDs (Universally Unique Identifiers) have been widely used to generate unique identifiers <a class="yt-timestamp" data-t="00:00:05">[00:00:05]</a>. They are 128-bit labels <a class="yt-timestamp" data-t="00:00:21">[00:00:21]</a> primarily created for operating systems and network protocols <a class="yt-timestamp" data-t="00:01:23">[00:01:23]</a>, where the size and format of identifiers are less critical <a class="yt-timestamp" data-t="00:01:28">[00:01:28]</a>. UUIDs are highly reliable in avoiding duplicates, with a very low probability of collision even when generating millions of IDs <a class="yt-timestamp" data-t="00:00:34">[00:00:34]</a>. However, for modern web applications, UUIDs present several significant drawbacks <a class="yt-timestamp" data-t="00:00:45">[00:00:45]</a>.

## [[drawbacks_of_using_uuids_in_web_applications | Drawbacks of using UUIDs in Web Applications]]

UUIDs are generally unsuitable for modern web applications due to several reasons:
*   **Length and Space** <a class="yt-timestamp" data-t="00:00:50">[00:00:50]</a>: They are too long, taking up significant space in databases <a class="yt-timestamp" data-t="00:00:54">[00:00:54]</a>.
*   **Usability** <a class="yt-timestamp" data-t="00:00:59">[00:00:59]</a>: UUIDs in URLs are hard to read, write, and type <a class="yt-timestamp" data-t="00:01:08">[00:01:08]</a>, making them complex and messy <a class="yt-timestamp" data-t="00:01:10">[00:01:10]</a>.
*   **Purpose Mismatch** <a class="yt-timestamp" data-t="00:01:16">[00:01:16]</a>: UUIDs were not designed for web applications <a class="yt-timestamp" data-t="00:01:18">[00:01:18]</a>, where performance, readability, scalability, and size are crucial considerations <a class="yt-timestamp" data-t="00:01:32">[00:01:32]</a>.

These limitations highlight the need for alternative unique identifier generation methods better suited for web environments.

## [[introduction_to_cuids_as_an_alternative_to_uuids | Introduction to CUIDs as an Alternative to UUIDs]]

CUIDs (Collision-resistant Unique Identifiers) offer an innovative solution to generate unique identifiers that overcome the limitations of UUIDs <a class="yt-timestamp" data-0:01:49>[00:01:49]</a>. They aim to be meaningful and short <a class="yt-timestamp" data-t="00:02:06">[00:02:06]</a>, making them highly suitable for web applications <a class="yt-timestamp" data-t="00:02:23">[00:02:23]</a>.

### CUID Structure and Advantages

A typical CUID format includes four components <a class="yt-timestamp" data-t="00:02:11">[00:02:11]</a>:
1.  A timestamp <a class="yt-timestamp" data-t="00:02:15">[00:02:15]</a>
2.  A fingerprint <a class="yt-timestamp" data-t="00:02:15">[00:02:15]</a>
3.  A random string <a class="yt-timestamp" data-t="00:02:16">[00:02:16]</a>
4.  A counter <a class="yt-timestamp" data-t="00:02:17">[00:02:17]</a>

CUIDs offer several advantages over UUIDs:
*   **Readability and Length**: They are shorter and more readable <a class="yt-timestamp" data-t="00:02:29">[00:02:29]</a>.
*   **Performance and Scalability**: CUIDs are scalable and performance-efficient <a class="yt-timestamp" data-t="00:02:32">[00:02:32]</a>.
*   **Security**: They are secure and unpredictable <a class="yt-timestamp" data-t="00:02:33">[00:02:33]</a>, ensuring uniqueness similar to UUIDs but in a more web-friendly format <a class="yt-timestamp" data-t="00:02:44">[00:02:44]</a>.

If using Prisma, CUIDs can be directly generated by the Prisma database <a class="yt-timestamp" data-t="00:01:49">[00:01:49]</a>.

## [[benefits_of_using_nanoids_over_uuids | Benefits of using Nanoids over UUIDs]]

Nanoids are another alternative, similar to UUIDs, but they generate unique identifiers within a fixed length <a class="yt-timestamp" data-t="00:02:54">[00:02:54]</a> using predefined alphabets <a class="yt-timestamp" data-t="00:02:59">[00:02:59]</a>.

### Efficiency and Collision Probability

The collision probability for Nanoids is significantly lower and more practical for typical application use:
*   For a 10-9 character length Nanoid, if 1,000 IDs are generated per second continuously for two years, there is only a 1% probability of a collision <a class="yt-timestamp" data-t="00:03:17">[00:03:17]</a>.
*   In contrast, a standard UUID has a collision probability corresponding to 126 years of continuous generation <a class="yt-timestamp" data-t="00:03:33">[00:03:33]</a>, which is far beyond the realistic operational lifespan for most identifiers <a class="yt-timestamp" data-t="00:03:39">[00:03:39]</a>.

This makes Nanoids a more efficient choice, as no one needs to operate a platform continuously for such extended periods just to encounter a collision <a class="yt-timestamp" data-t="00:03:48">[00:03:48]</a>. For custom identifier generation, the `nanoid` package can be installed and utilized <a class="yt-timestamp" data-t="00:04:27">[00:04:27]</a>.

## [[comparison_of_uuids_cuids_and_nanoids | Comparison of UUIDs, CUIDs, and Nanoids]]

| Feature              | UUIDs                                 | CUIDs                                | Nanoids                                    |
| :------------------- | :------------------------------------ | :----------------------------------- | :----------------------------------------- |
| **Primary Use**      | Operating systems, network protocols <a class="yt-timestamp" data-t="00:01:23">[00:01:23]</a> | Web applications <a class="yt-timestamp" data-t="00:02:23">[00:02:23]</a> | Web applications <a class="yt-timestamp" data-t="00:02:54">[00:02:54]</a> |
| **Length/Size**      | Long (128-bit) <a class="yt-timestamp" data-t="00:00:54">[00:00:54]</a>                     | Shorter <a class="yt-timestamp" data-t="00:02:29">[00:02:29]</a>                           | Fixed length <a class="yt-timestamp" data-t="00:02:56">[00:02:56]</a>                   |
| **Readability**      | Hard to read/write <a class="yt-timestamp" data-t="00:01:08">[00:01:08]</a>                | Readable <a class="yt-timestamp" data-t="00:02:29">[00:02:29]</a>                       | Depends on alphabet/length                  |
| **Performance**      | Not optimized for web performance <a class="yt-timestamp" data-t="00:01:34">[00:01:34]</a> | Performance efficient <a class="yt-timestamp" data-t="00:02:32">[00:02:32]</a>        | Performance efficient <a class="yt-timestamp" data-t="00:02:49">[00:02:49]</a>        |
| **Collision Risk**   | Very low (126 years for 1% probability) <a class="yt-timestamp" data-t="00:03:33">[00:03:33]</a> | Low <a class="yt-timestamp" data-t="00:02:38">[00:02:38]</a>                            | Low (2 years for 1% probability at 1000 IDs/s) <a class="yt-timestamp" data-t="00:03:20">[00:03:20]</a> |

For modern web applications, CUIDs and Nanoids are superior choices to UUIDs due to their optimized size, readability, and performance characteristics <a class="yt-timestamp" data-t="00:02:46">[00:02:46]</a>.