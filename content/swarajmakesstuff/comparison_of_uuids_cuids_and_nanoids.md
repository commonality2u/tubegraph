---
title: Comparison of UUIDs CUIDs and Nanoids
videoId: toszy9D3kgE
---

From: [[swarajmakesstuff]] <br/> 

While [[Introduction to CUIDs as an alternative to UUIDs | UUIDs]] (Universally Unique Identifiers) have been widely used for generating unique identifiers, they present significant [[Drawbacks of using UUIDs in web applications | drawbacks]] for modern web applications. Alternatives like CUIDs and Nanoids offer more suitable solutions <a class="yt-timestamp" data-t="00:00:00">[00:00:00]</a>.

## UUIDs (Universally Unique Identifiers)

UUIDs are 128-bit labels used to store information in operating systems <a class="yt-timestamp" data-t="00:00:21">[00:00:21]</a>. They are commonly used because the probability of duplication is very low; even generating millions of UUIDs would unlikely result in a duplicate <a class="yt-timestamp" data-t="00:00:33">[00:00:33]</a>.

### Drawbacks of UUIDs in Web Applications

Despite their uniqueness, UUIDs have serious [[Drawbacks of using UUIDs in web applications | drawbacks]] that make them unsuitable for modern web applications <a class="yt-timestamp" data-t="00:00:45">[00:00:45]</a>:

*   **Excessive Length**: UUIDs are too long, taking up significant space in databases, user interfaces, and URLs <a class="yt-timestamp" data-t="00:00:54">[00:00:54]</a>. They are hard to read, write, and type, making them complex and messy <a class="yt-timestamp" data-t="00:01:08">[00:01:08]</a>.
*   **Misaligned Purpose**: UUIDs were primarily created for operating systems and network protocols, where the size and format of identifiers are not critical <a class="yt-timestamp" data-t="00:01:18">[00:01:18]</a>. This contrasts with web applications, which demand consideration for performance, readability, scalability, and size <a class="yt-timestamp" data-t="00:01:30">[00:01:30]</a>. UUIDs do not meet these requirements <a class="yt-timestamp" data-t="00:01:39">[00:01:39]</a>.

## CUIDs (Collision Resistant Unique Identifiers)

CUIDs are an [[Introduction to CUIDs as an alternative to UUIDs | innovative alternative]] to UUIDs designed for web applications <a class="yt-timestamp" data-t="00:01:46">[00:01:46]</a>. They aim to generate unique identifiers that are both meaningful and short <a class="yt-timestamp" data-t="00:02:04">[00:02:04]</a>.

### CUID Structure

A CUID typically includes four components that contribute to its uniqueness and suitability for web applications <a class="yt-timestamp" data-t="00:02:11">[00:02:11]</a>:
*   Timestamp <a class="yt-timestamp" data-t="00:02:13">[00:02:13]</a>
*   Fingerprint <a class="yt-timestamp" data-t="00:02:15">[00:02:15]</a>
*   Random string <a class="yt-timestamp" data-t="00:02:16">[00:02:16]</a>
*   Counter <a class="yt-timestamp" data-t="00:02:17">[00:02:17]</a>

### Advantages of CUIDs

CUIDs offer several advantages over UUIDs, particularly for [[Use cases and efficiency of CUIDs and Nanoids | web applications]] <a class="yt-timestamp" data-t="00:02:25">[00:02:25]</a>:
*   **Readability**: They are easier to read <a class="yt-timestamp" data-t="00:02:29">[00:02:29]</a>.
*   **Shorter Length**: CUIDs are shorter than UUIDs <a class="yt-timestamp" data-t="00:02:30">[00:02:30]</a>.
*   **Scalability & Performance**: They are scalable and performance-efficient <a class="yt-timestamp" data-t="00:02:32">[00:02:32]</a>.
*   **Security & Unpredictability**: CUIDs maintain security and unpredictability, similar to the reasons UUIDs are chosen, while still providing unique identifiers <a class="yt-timestamp" data-t="00:02:33">[00:02:33]</a>.

## Nanoids

Nanoids are another modern alternative for generating unique identifiers <a class="yt-timestamp" data-t="00:02:51">[00:02:51]</a>. They generate unique identifiers within a fixed length using random strings and predefined alphabets <a class="yt-timestamp" data-t="00:02:54">[00:02:54]</a>.

### Collision Probability and Practicality

[[Benefits of using Nanoids over UUIDs | Nanoids]] demonstrate practical collision resistance <a class="yt-timestamp" data-t="00:03:06">[00:03:06]</a>:
*   A 10-9 character Nanoid, generating 1000 IDs per second, would have a 1% probability of collision after continuous generation for two years <a class="yt-timestamp" data-t="00:03:17">[00:03:17]</a>.
*   This contrasts with UUIDs, which would take approximately 126 years to reach a similar collision probability <a class="yt-timestamp" data-t="00:03:33">[00:03:33]</a>.

Given that no platform runs continuously for 126 years just to generate IDs, a Nanoid is generally more practical than a UUID <a class="yt-timestamp" data-t="00:03:45">[00:03:45]</a>.

## Recommendations for Implementation

*   If using Prisma, CUIDs can be directly generated by the Prisma database <a class="yt-timestamp" data-t="00:04:18">[00:04:18]</a>.
*   For setting up your own project, the Nano ID package can be used by installing the `nanoid` library via NVM <a class="yt-timestamp" data-t="00:04:24">[00:04:24]</a>.